<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Door of Destiny - 3D Co-op Quiz</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            overflow: hidden;
            height: 100vh;
        }
        
        #gameContainer {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        /* Menu Styles */
        #menuScreen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            padding: 20px;
            text-align: center;
            background: radial-gradient(circle at center, #0f3460 0%, #16213e 100%);
            z-index: 100;
            position: relative;
        }
        
        .hidden {
            display: none !important;
        }
        
        .game-title {
            font-size: 4rem;
            background: linear-gradient(45deg, #ff9a00, #ff5252);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 1rem;
            text-shadow: 0 0 30px rgba(255, 82, 82, 0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { text-shadow: 0 0 20px rgba(255, 154, 0, 0.5); }
            to { text-shadow: 0 0 30px rgba(255, 82, 82, 0.8); }
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: #8f9bba;
            margin-bottom: 3rem;
            max-width: 600px;
        }
        
        .menu-section {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 2rem;
            margin: 1rem 0;
            width: 90%;
            max-width: 500px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .menu-btn {
            background: linear-gradient(45deg, #4a00e0, #8e2de2);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.1rem;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px 0;
            width: 100%;
            max-width: 300px;
            font-weight: 600;
            letter-spacing: 1px;
        }
        
        .menu-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(142, 45, 226, 0.4);
        }
        
        .input-group {
            margin: 20px 0;
        }
        
        input[type="text"], select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 12px 15px;
            border-radius: 8px;
            width: 100%;
            margin: 5px 0;
            font-size: 1rem;
        }
        
        input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        
        .player-list {
            margin-top: 20px;
        }
        
        .player-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 8px;
            margin: 5px 0;
            display: flex;
            align-items: center;
        }
        
        .player-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 10px;
        }
        
        /* Game UI */
        #gameUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            z-index: 10;
            pointer-events: none;
        }
        
        .ui-container {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        
        .player-stats {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 200px;
            pointer-events: all;
            border-left: 4px solid;
        }
        
        .player1-stats { border-color: #00ff9d; }
        .player2-stats { border-color: #00b8ff; }
        
        .player-name {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .player-score {
            font-size: 1.5rem;
            color: #ffcc00;
        }
        
        .lives {
            display: flex;
            margin-top: 10px;
        }
        
        .life {
            width: 15px;
            height: 15px;
            background: #ff5252;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .life.lost {
            background: rgba(255, 82, 82, 0.3);
        }
        
        #questionDisplay {
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 15px;
            max-width: 600px;
            margin: 0 auto;
            text-align: center;
            pointer-events: all;
            border: 2px solid #4a00e0;
            box-shadow: 0 0 30px rgba(74, 0, 224, 0.5);
        }
        
        #category {
            color: #8e2de2;
            font-size: 1rem;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        #questionText {
            font-size: 1.3rem;
            line-height: 1.5;
            margin-bottom: 20px;
        }
        
        #timer {
            width: 100%;
            height: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin-top: 10px;
            overflow: hidden;
        }
        
        #timerBar {
            height: 100%;
            background: linear-gradient(90deg, #00ff9d, #00b8ff);
            width: 100%;
            transition: width 1s linear;
        }
        
        #chatBox {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            overflow: hidden;
            pointer-events: all;
        }
        
        #chatMessages {
            height: 200px;
            overflow-y: auto;
            padding: 10px;
        }
        
        .chat-message {
            margin: 5px 0;
            padding: 8px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
        }
        
        #chatInput {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
        }
        
        /* Game Over Screen */
        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        
        .result-title {
            font-size: 3rem;
            margin-bottom: 2rem;
            background: linear-gradient(45deg, #ff9a00, #ff5252);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .final-score {
            font-size: 2rem;
            color: #ffcc00;
            margin-bottom: 2rem;
        }
        
        /* Canvas */
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .game-title { font-size: 2.5rem; }
            .ui-container { flex-direction: column; }
            .player-stats { margin-bottom: 10px; }
            #questionDisplay { padding: 15px; font-size: 0.9rem; }
            #chatBox { width: 250px; }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
</head>
<body>
    <!-- Menu Screen -->
    <div id="menuScreen">
        <h1 class="game-title">üö™ DOOR OF DESTINY</h1>
        <p class="subtitle">Answer quiz questions correctly to survive. Choose the wrong door and face the consequences. Cooperate to win!</p>
        
        <div class="menu-section">
            <h2>üéÆ Game Setup</h2>
            <div class="input-group">
                <input type="text" id="playerName" placeholder="Enter your name" maxlength="15">
                <select id="languageSelect">
                    <option value="en">English</option>
                    <option value="fr">French</option>
                    <option value="ar">Arabic</option>
                </select>
            </div>
            <button class="menu-btn" id="createRoomBtn">üè† Create Room</button>
            <div class="input-group" id="joinRoomGroup" style="display:none;">
                <input type="text" id="roomCode" placeholder="Enter room code">
                <button class="menu-btn" id="joinRoomBtn">üîó Join Room</button>
            </div>
            <button class="menu-btn" id="toggleJoinBtn">üîó Join Existing Room</button>
        </div>
        
        <div class="menu-section" id="roomInfo" style="display:none;">
            <h2>üë• Room: <span id="roomCodeDisplay"></span></h2>
            <p>Share this code with your friend:</p>
            <h2 id="shareCode" style="color:#00ff9d; font-size:2rem;"></h2>
            <div class="player-list" id="playerList">
                <!-- Players will appear here -->
            </div>
            <button class="menu-btn" id="startGameBtn" style="background:linear-gradient(45deg, #00b09b, #96c93d);">üöÄ Start Game</button>
        </div>
        
        <div class="menu-section">
            <h2>üìñ How to Play</h2>
            <p>‚Ä¢ 2-4 players can play together</p>
            <p>‚Ä¢ Questions appear above doors</p>
            <p>‚Ä¢ Choose correct door to survive</p>
            <p>‚Ä¢ Wrong door = lose a life</p>
            <p>‚Ä¢ Work together to reach the highest level!</p>
        </div>
    </div>
    
    <!-- Game Container -->
    <div id="gameContainer" class="hidden">
        <!-- Game UI -->
        <div id="gameUI">
            <div class="ui-container">
                <div class="player-stats player1-stats">
                    <div class="player-name" id="player1Name">Player 1</div>
                    <div class="player-score">Score: <span id="player1Score">0</span></div>
                    <div class="lives" id="player1Lives">
                        <div class="life"></div>
                        <div class="life"></div>
                        <div class="life"></div>
                    </div>
                </div>
                
                <div id="questionDisplay" class="hidden">
                    <div id="category">Geography</div>
                    <div id="questionText">Which country has the largest population?</div>
                    <div id="timer"><div id="timerBar"></div></div>
                </div>
                
                <div class="player-stats player2-stats">
                    <div class="player-name" id="player2Name">Player 2</div>
                    <div class="player-score">Score: <span id="player2Score">0</span></div>
                    <div class="lives" id="player2Lives">
                        <div class="life"></div>
                        <div class="life"></div>
                        <div class="life"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Chat Box -->
        <div id="chatBox">
            <div id="chatMessages"></div>
            <input type="text" id="chatInput" placeholder="Type message...">
        </div>
        
        <!-- Game Canvas -->
        <canvas id="gameCanvas"></canvas>
        
        <!-- Game Over Screen -->
        <div id="gameOverScreen" class="hidden">
            <h1 class="result-title">GAME OVER</h1>
            <div class="final-score">Final Score: <span id="finalScore">0</span></div>
            <div class="final-score">Level Reached: <span id="finalLevel">1</span></div>
            <button class="menu-btn" id="playAgainBtn">üîÑ Play Again</button>
            <button class="menu-btn" id="backToMenuBtn">üè† Back to Menu</button>
        </div>
    </div>

    <script>
        // Game Configuration
        const CONFIG = {
            LIVES: 3,
            QUESTION_TIME: 30,
            LEVELS: [
                { doors: 3, time: 30, points: 100 },
                { doors: 3, time: 25, points: 150 },
                { doors: 4, time: 25, points: 200 },
                { doors: 4, time: 20, points: 250 },
                { doors: 5, time: 20, points: 300 }
            ],
            PLAYER_COLORS: [
                0x00ff9d, // Green
                0x00b8ff, // Blue
                0xff5252, // Red
                0xff9a00  // Orange
            ],
            DOOR_COLORS: {
                DEFAULT: 0x8e2de2,
                CORRECT: 0x00ff9d,
                WRONG: 0xff5252,
                SELECTED: 0x00b8ff
            }
        };

        // Game State
        let gameState = {
            players: {},
            currentPlayerId: null,
            roomCode: null,
            isHost: false,
            gameActive: false,
            currentLevel: 0,
            currentQuestion: null,
            selectedDoor: null,
            timer: null,
            timeLeft: CONFIG.QUESTION_TIME
        };

        // Three.js Variables
        let scene, camera, renderer, controls;
        let doors = [];
        let playerMeshes = {};
        let street, streetLines;

        // DOM Elements
        const menuScreen = document.getElementById('menuScreen');
        const gameContainer = document.getElementById('gameContainer');
        const playerNameInput = document.getElementById('playerName');
        const languageSelect = document.getElementById('languageSelect');
        const createRoomBtn = document.getElementById('createRoomBtn');
        const joinRoomGroup = document.getElementById('joinRoomGroup');
        const toggleJoinBtn = document.getElementById('toggleJoinBtn');
        const roomCodeInput = document.getElementById('roomCode');
        const joinRoomBtn = document.getElementById('joinRoomBtn');
        const roomInfo = document.getElementById('roomInfo');
        const roomCodeDisplay = document.getElementById('roomCodeDisplay');
        const shareCode = document.getElementById('shareCode');
        const playerList = document.getElementById('playerList');
        const startGameBtn = document.getElementById('startGameBtn');
        const questionDisplay = document.getElementById('questionDisplay');
        const questionText = document.getElementById('questionText');
        const categoryDisplay = document.getElementById('category');
        const timerBar = document.getElementById('timerBar');
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const playAgainBtn = document.getElementById('playAgainBtn');
        const backToMenuBtn = document.getElementById('backToMenuBtn');

        // WebRTC for Multiplayer
        let peerConnection = null;
        let dataChannel = null;
        let isHost = false;

        // Initialize
        function init() {
            setupEventListeners();
            generateDefaultPlayerName();
        }

        function generateDefaultPlayerName() {
            const adjectives = ['Brave', 'Clever', 'Swift', 'Wise', 'Bold'];
            const nouns = ['Explorer', 'Scholar', 'Hero', 'Champion', 'Traveler'];
            const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
            const noun = nouns[Math.floor(Math.random() * nouns.length)];
            playerNameInput.value = `${adj} ${noun}`;
        }

        function setupEventListeners() {
            createRoomBtn.addEventListener('click', createRoom);
            toggleJoinBtn.addEventListener('click', () => {
                joinRoomGroup.style.display = joinRoomGroup.style.display === 'none' ? 'block' : 'none';
            });
            joinRoomBtn.addEventListener('click', joinRoom);
            startGameBtn.addEventListener('click', startGame);
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && chatInput.value.trim()) {
                    sendChatMessage(chatInput.value);
                    chatInput.value = '';
                }
            });
            playAgainBtn.addEventListener('click', resetGame);
            backToMenuBtn.addEventListener('click', () => {
                gameOverScreen.classList.add('hidden');
                menuScreen.classList.remove('hidden');
                gameContainer.classList.add('hidden');
                disconnectMultiplayer();
            });

            // Window resize
            window.addEventListener('resize', onWindowResize);
        }

        // Multiplayer Functions
        function createRoom() {
            const playerName = playerNameInput.value.trim() || 'Player';
            const language = languageSelect.value;
            
            gameState.currentPlayerId = generatePlayerId();
            gameState.isHost = true;
            gameState.roomCode = generateRoomCode();
            
            // Add host player
            gameState.players[gameState.currentPlayerId] = {
                id: gameState.currentPlayerId,
                name: playerName,
                color: CONFIG.PLAYER_COLORS[0],
                score: 0,
                lives: CONFIG.LIVES,
                language: language,
                position: { x: -2, y: 0.5, z: 0 }
            };
            
            updateRoomDisplay();
            setupWebRTCAsHost();
            
            menuScreen.classList.add('hidden');
            roomInfo.classList.remove('hidden');
        }

        function joinRoom() {
            const playerName = playerNameInput.value.trim() || 'Player';
            const language = languageSelect.value;
            const code = roomCodeInput.value.trim().toUpperCase();
            
            if (!code || code.length !== 6) {
                alert('Please enter a valid 6-character room code');
                return;
            }
            
            gameState.currentPlayerId = generatePlayerId();
            gameState.isHost = false;
            gameState.roomCode = code;
            
            gameState.players[gameState.currentPlayerId] = {
                id: gameState.currentPlayerId,
                name: playerName,
                color: CONFIG.PLAYER_COLORS[Object.keys(gameState.players).length],
                score: 0,
                lives: CONFIG.LIVES,
                language: language,
                position: { x: 2, y: 0.5, z: 0 }
            };
            
            updateRoomDisplay();
            setupWebRTCAsClient();
            
            menuScreen.classList.add('hidden');
            roomInfo.classList.remove('hidden');
        }

        function generateRoomCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function generatePlayerId() {
            return 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function updateRoomDisplay() {
            roomCodeDisplay.textContent = gameState.roomCode;
            shareCode.textContent = gameState.roomCode;
            
            // Update player list
            playerList.innerHTML = '';
            Object.values(gameState.players).forEach((player, index) => {
                const playerElement = document.createElement('div');
                playerElement.className = 'player-item';
                playerElement.innerHTML = `
                    <div class="player-color" style="background-color: #${player.color.toString(16).padStart(6, '0')}"></div>
                    ${player.name} ${player.id === gameState.currentPlayerId ? '(You)' : ''}
                `;
                playerList.appendChild(playerElement);
            });
        }

        // WebRTC Setup (Simplified - In real implementation, use proper signaling)
        function setupWebRTCAsHost() {
            // Simplified - In production, use proper WebRTC with STUN/TURN
            console.log('Host setup - would connect via WebRTC in production');
            
            // Simulate another player joining for demo
            setTimeout(() => {
                if (!gameState.players['demo_player']) {
                    gameState.players['demo_player'] = {
                        id: 'demo_player',
                        name: 'Demo Player',
                        color: CONFIG.PLAYER_COLORS[1],
                        score: 0,
                        lives: CONFIG.LIVES,
                        language: 'en',
                        position: { x: 2, y: 0.5, z: 0 }
                    };
                    updateRoomDisplay();
                }
            }, 1000);
        }

        function setupWebRTCAsClient() {
            console.log('Client setup - would connect via WebRTC in production');
        }

        function sendGameState() {
            // In production, send via WebRTC data channel
            console.log('Sending game state to other players');
        }

        function disconnectMultiplayer() {
            // Clean up WebRTC connections
            gameState.players = {};
        }

        // Game Functions
        function startGame() {
            roomInfo.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            
            init3DScene();
            startGameLoop();
            showQuestion();
        }

        function init3DScene() {
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x16213e, 10, 50);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Street
            createStreet();
            
            // Initial doors
            createDoors(CONFIG.LEVELS[0].doors);
            
            // Create player meshes
            createPlayerMeshes();
            
            // Controls (for debugging - disable in production)
            // controls = new THREE.OrbitControls(camera, renderer.domElement);
            
            // Handle window resize
            onWindowResize();
        }

        function createStreet() {
            // Street floor
            const streetGeometry = new THREE.PlaneGeometry(20, 100);
            const streetMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a2e,
                roughness: 0.8,
                metalness: 0.2
            });
            street = new THREE.Mesh(streetGeometry, streetMaterial);
            street.rotation.x = -Math.PI / 2;
            street.receiveShadow = true;
            scene.add(street);
            
            // Street lines
            const lineGeometry = new THREE.BoxGeometry(2, 0.1, 0.2);
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            
            streetLines = new THREE.Group();
            for (let i = -40; i < 40; i += 4) {
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.position.set(0, 0.01, i);
                streetLines.add(line);
            }
            scene.add(streetLines);
            
            // Street borders
            const borderGeometry = new THREE.BoxGeometry(0.5, 0.5, 100);
            const borderMaterial = new THREE.MeshStandardMaterial({ color: 0x8e2de2 });
            
            const leftBorder = new THREE.Mesh(borderGeometry, borderMaterial);
            leftBorder.position.set(-4.5, 0.25, 0);
            leftBorder.castShadow = true;
            scene.add(leftBorder);
            
            const rightBorder = new THREE.Mesh(borderGeometry, borderMaterial);
            rightBorder.position.set(4.5, 0.25, 0);
            rightBorder.castShadow = true;
            scene.add(rightBorder);
            
            // Background buildings (simple)
            for (let i = -3; i <= 3; i += 2) {
                if (i === 0) continue;
                
                const buildingGeometry = new THREE.BoxGeometry(3, Math.random() * 10 + 5, 2);
                const buildingMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x2a2a4a,
                    roughness: 0.9
                });
                
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                building.position.set(i * 3, buildingGeometry.parameters.height / 2, -15);
                building.castShadow = true;
                scene.add(building);
            }
        }

        function createDoors(count) {
            // Remove existing doors
            doors.forEach(door => scene.remove(door));
            doors = [];
            
            const doorWidth = 1.5;
            const spacing = 3;
            const startX = -((count - 1) * spacing) / 2;
            
            for (let i = 0; i < count; i++) {
                const doorGroup = new THREE.Group();
                
                // Door frame
                const frameGeometry = new THREE.BoxGeometry(doorWidth, 3, 0.2);
                const frameMaterial = new THREE.MeshStandardMaterial({ 
                    color: CONFIG.DOOR_COLORS.DEFAULT,
                    emissive: 0x222222,
                    emissiveIntensity: 0.2
                });
                const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                frame.castShadow = true;
                frame.receiveShadow = true;
                doorGroup.add(frame);
                
                // Door handle
                const handleGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const handleMaterial = new THREE.MeshStandardMaterial({ color: 0xffcc00 });
                const handle = new THREE.Mesh(handleGeometry, handleMaterial);
                handle.position.set(doorWidth / 2 - 0.1, 0, 0.11);
                doorGroup.add(handle);
                
                // Question panel above door
                const panelGeometry = new THREE.BoxGeometry(doorWidth, 0.5, 0.1);
                const panelMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                panel.position.set(0, 2, 0.11);
                doorGroup.add(panel);
                
                // Position door
                doorGroup.position.set(startX + i * spacing, 1.5, -5);
                doorGroup.userData = {
                    id: i,
                    isCorrect: false,
                    answer: ''
                };
                
                scene.add(doorGroup);
                doors.push(doorGroup);
            }
        }

        function createPlayerMeshes() {
            Object.values(gameState.players).forEach(player => {
                // Player capsule
                const group = new THREE.Group();
                
                // Body
                const bodyGeometry = new THREE.CapsuleGeometry(0.3, 0.8, 4, 8);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: player.color,
                    emissive: player.color,
                    emissiveIntensity: 0.2
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                group.add(body);
                
                // Glow effect
                const glowGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: player.color,
                    transparent: true,
                    opacity: 0.3
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                group.add(glow);
                
                // Name label
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                
                context.fillStyle = `#${player.color.toString(16).padStart(6, '0')}`;
                context.font = '24px Arial';
                context.textAlign = 'center';
                context.fillText(player.name, 128, 40);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.y = 1.5;
                sprite.scale.set(2, 0.5, 1);
                group.add(sprite);
                
                group.position.set(player.position.x, player.position.y, player.position.z);
                scene.add(group);
                
                playerMeshes[player.id] = group;
            });
        }

        function showQuestion() {
            // Fetch question from API
            fetchQuestion().then(question => {
                if (!question) {
                    // Fallback questions if API fails
                    question = getFallbackQuestion();
                }
                
                gameState.currentQuestion = question;
                gameState.timeLeft = CONFIG.LEVELS[gameState.currentLevel].time;
                
                // Update UI
                questionDisplay.classList.remove('hidden');
                questionText.textContent = question.question;
                categoryDisplay.textContent = question.category;
                
                // Reset timer bar
                timerBar.style.width = '100%';
                
                // Set correct door
                const correctDoorIndex = Math.floor(Math.random() * doors.length);
                doors.forEach((door, index) => {
                    door.userData.isCorrect = index === correctDoorIndex;
                    door.userData.answer = index === correctDoorIndex ? 
                        question.correct_answer : question.incorrect_answers[index] || `Option ${index + 1}`;
                    
                    // Update door color
                    const frame = door.children[0];
                    frame.material.color.setHex(CONFIG.DOOR_COLORS.DEFAULT);
                });
                
                // Start timer
                startTimer();
            });
        }

        async function fetchQuestion() {
            try {
                // Try Open Trivia DB first
                const response = await fetch('https://opentdb.com/api.php?amount=1&type=multiple');
                const data = await response.json();
                
                if (data.results && data.results.length > 0) {
                    const question = data.results[0];
                    
                    // Decode HTML entities
                    const decodeHTML = (html) => {
                        const txt = document.createElement('textarea');
                        txt.innerHTML = html;
                        return txt.value;
                    };
                    
                    return {
                        question: decodeHTML(question.question),
                        correct_answer: decodeHTML(question.correct_answer),
                        incorrect_answers: question.incorrect_answers.map(decodeHTML),
                        category: question.category
                    };
                }
            } catch (error) {
                console.log('Using fallback questions');
            }
            
            return null;
        }

        function getFallbackQuestion() {
            const questions = [
                {
                    question: "What is the capital of France?",
                    correct_answer: "Paris",
                    incorrect_answers: ["London", "Berlin", "Madrid"],
                    category: "Geography"
                },
                {
                    question: "Which planet is known as the Red Planet?",
                    correct_answer: "Mars",
                    incorrect_answers: ["Venus", "Jupiter", "Saturn"],
                    category: "Science"
                },
                {
                    question: "What is the largest ocean on Earth?",
                    correct_answer: "Pacific Ocean",
                    incorrect_answers: ["Atlantic Ocean", "Indian Ocean", "Arctic Ocean"],
                    category: "Geography"
                },
                {
                    question: "Who painted the Mona Lisa?",
                    correct_answer: "Leonardo da Vinci",
                    incorrect_answers: ["Pablo Picasso", "Vincent van Gogh", "Michelangelo"],
                    category: "Art"
                },
                {
                    question: "What is the chemical symbol for gold?",
                    correct_answer: "Au",
                    incorrect_answers: ["Ag", "Fe", "Cu"],
                    category: "Science"
                }
            ];
            
            return questions[Math.floor(Math.random() * questions.length)];
        }

        function startTimer() {
            clearInterval(gameState.timer);
            
            gameState.timer = setInterval(() => {
                gameState.timeLeft--;
                const percentage = (gameState.timeLeft / CONFIG.LEVELS[gameState.currentLevel].time) * 100;
                timerBar.style.width = `${percentage}%`;
                
                if (gameState.timeLeft <= 0) {
                    clearInterval(gameState.timer);
                    handleTimeOut();
                }
            }, 1000);
        }

        function handleTimeOut() {
            // Time's up - wrong answer
            const currentPlayer = gameState.players[gameState.currentPlayerId];
            currentPlayer.lives--;
            updatePlayerUI();
            
            if (currentPlayer.lives <= 0) {
                endGame();
            } else {
                setTimeout(showQuestion, 2000);
            }
        }

        function selectDoor(doorIndex) {
            if (gameState.selectedDoor !== null) return;
            
            gameState.selectedDoor = doorIndex;
            const door = doors[doorIndex];
            
            // Highlight selected door
            const frame = door.children[0];
            frame.material.color.setHex(CONFIG.DOOR_COLORS.SELECTED);
            
            // Check answer after delay
            setTimeout(() => {
                checkAnswer(doorIndex);
            }, 1000);
        }

        function checkAnswer(doorIndex) {
            clearInterval(gameState.timer);
            
            const door = doors[doorIndex];
            const isCorrect = door.userData.isCorrect;
            const currentPlayer = gameState.players[gameState.currentPlayerId];
            
            // Update door color
            const frame = door.children[0];
            frame.material.color.setHex(isCorrect ? CONFIG.DOOR_COLORS.CORRECT : CONFIG.DOOR_COLORS.WRONG);
            
            if (isCorrect) {
                // Correct answer
                currentPlayer.score += CONFIG.LEVELS[gameState.currentLevel].points;
                updatePlayerUI();
                
                // Move to next level
                setTimeout(() => {
                    gameState.currentLevel++;
                    if (gameState.currentLevel >= CONFIG.LEVELS.length) {
                        // Game completed
                        currentPlayer.score += 1000; // Bonus
                        endGame(true);
                    } else {
                        // Create new doors for next level
                        createDoors(CONFIG.LEVELS[gameState.currentLevel].doors);
                        gameState.selectedDoor = null;
                        showQuestion();
                    }
                }, 2000);
            } else {
                // Wrong answer
                currentPlayer.lives--;
                updatePlayerUI();
                
                if (currentPlayer.lives <= 0) {
                    endGame();
                } else {
                    setTimeout(() => {
                        gameState.selectedDoor = null;
                        showQuestion();
                    }, 2000);
                }
            }
        }

        function updatePlayerUI() {
            Object.values(gameState.players).forEach((player, index) => {
                const playerNum = index + 1;
                document.getElementById(`player${playerNum}Name`).textContent = player.name;
                document.getElementById(`player${playerNum}Score`).textContent = player.score;
                
                const livesContainer = document.getElementById(`player${playerNum}Lives`);
                livesContainer.innerHTML = '';
                
                for (let i = 0; i < CONFIG.LIVES; i++) {
                    const life = document.createElement('div');
                    life.className = `life ${i >= player.lives ? 'lost' : ''}`;
                    livesContainer.appendChild(life);
                }
            });
        }

        function endGame(isVictory = false) {
            gameState.gameActive = false;
            clearInterval(gameState.timer);
            
            document.getElementById('finalScore').textContent = 
                gameState.players[gameState.currentPlayerId].score;
            document.getElementById('finalLevel').textContent = 
                gameState.currentLevel + 1;
            
            gameOverScreen.classList.remove('hidden');
            
            if (isVictory) {
                document.querySelector('.result-title').textContent = 'VICTORY!';
                document.querySelector('.result-title').style.background = 
                    'linear-gradient(45deg, #00ff9d, #00b8ff)';
            }
        }

        function resetGame() {
            gameState.currentLevel = 0;
            gameState.selectedDoor = null;
            gameState.timeLeft = CONFIG.QUESTION_TIME;
            
            Object.values(gameState.players).forEach(player => {
                player.score = 0;
                player.lives = CONFIG.LIVES;
            });
            
            updatePlayerUI();
            gameOverScreen.classList.add('hidden');
            
            createDoors(CONFIG.LEVELS[0].doors);
            showQuestion();
        }

        function sendChatMessage(message) {
            const player = gameState.players[gameState.currentPlayerId];
            const chatMessage = document.createElement('div');
            chatMessage.className = 'chat-message';
            chatMessage.innerHTML = `<strong>${player.name}:</strong> ${message}`;
            chatMessages.appendChild(chatMessage);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            // In production, send via WebRTC to other players
        }

        // Game Loop
        function startGameLoop() {
            function animate() {
                requestAnimationFrame(animate);
                
                // Animate street lines
                if (streetLines) {
                    streetLines.position.z += 0.1;
                    if (streetLines.position.z > 4) {
                        streetLines.position.z = -40;
                    }
                }
                
                // Animate player glow
                Object.values(playerMeshes).forEach(mesh => {
                    const glow = mesh.children[1];
                    glow.scale.x = 1 + Math.sin(Date.now() * 0.002) * 0.1;
                    glow.scale.y = 1 + Math.sin(Date.now() * 0.002) * 0.1;
                    glow.scale.z = 1 + Math.sin(Date.now() * 0.002) * 0.1;
                });
                
                // Update camera to follow player
                const currentPlayer = gameState.players[gameState.currentPlayerId];
                if (currentPlayer && camera) {
                    const targetZ = currentPlayer.position.z - 10;
                    camera.position.z += (targetZ - camera.position.z) * 0.05;
                }
                
                renderer.render(scene, camera);
            }
            animate();
        }

        // Handle Window Resize
        function onWindowResize() {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // Handle Keyboard Input
        document.addEventListener('keydown', (event) => {
            if (!gameState.gameActive) return;
            
            const currentPlayer = gameState.players[gameState.currentPlayerId];
            if (!currentPlayer) return;
            
            // Move player
            switch(event.key) {
                case 'ArrowLeft':
                case 'a':
                    currentPlayer.position.x = Math.max(-4, currentPlayer.position.x - 1);
                    break;
                case 'ArrowRight':
                case 'd':
                    currentPlayer.position.x = Math.min(4, currentPlayer.position.x + 1);
                    break;
                case '1':
                    selectDoor(0);
                    break;
                case '2':
                    selectDoor(1);
                    break;
                case '3':
                    selectDoor(2);
                    break;
                case '4':
                    selectDoor(3);
                    break;
                case '5':
                    selectDoor(4);
                    break;
            }
            
            // Update player mesh position
            if (playerMeshes[currentPlayer.id]) {
                playerMeshes[currentPlayer.id].position.x = currentPlayer.position.x;
            }
            
            // In production, send position updates to other players
        });

        // Initialize game
        init();
    </script>
</body>
</html>
