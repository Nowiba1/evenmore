<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mission Extraction - Local Network Multiplayer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0c0c1d 0%, #1a1a2e 100%);
            color: #e0e0ff;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        /* Screens */
        .screen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 20px;
            transition: opacity 0.5s;
        }
        
        .screen.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        /* Main Menu */
        .title {
            font-size: 3.5rem;
            font-weight: 800;
            text-align: center;
            margin-bottom: 20px;
            background: linear-gradient(90deg, #4cc9f0, #4361ee);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 20px rgba(76, 201, 240, 0.3);
            letter-spacing: 2px;
        }
        
        .subtitle {
            font-size: 1.2rem;
            margin-bottom: 40px;
            text-align: center;
            color: #a0a0ff;
            max-width: 600px;
        }
        
        /* Room Controls */
        .room-controls {
            background: rgba(20, 20, 40, 0.8);
            border-radius: 15px;
            padding: 30px;
            width: 100%;
            max-width: 500px;
            border: 1px solid rgba(76, 201, 240, 0.3);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            margin-bottom: 30px;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #4cc9f0;
        }
        
        input {
            width: 100%;
            padding: 12px 15px;
            background: rgba(10, 10, 25, 0.8);
            border: 1px solid #4361ee;
            border-radius: 8px;
            color: white;
            font-size: 1.1rem;
            letter-spacing: 2px;
            text-align: center;
        }
        
        input:focus {
            outline: none;
            border-color: #4cc9f0;
            box-shadow: 0 0 10px rgba(76, 201, 240, 0.5);
        }
        
        .btn {
            display: block;
            width: 100%;
            padding: 15px;
            margin-top: 15px;
            background: linear-gradient(90deg, #4361ee, #3a0ca3);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 7px 15px rgba(67, 97, 238, 0.4);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn-secondary {
            background: linear-gradient(90deg, #f72585, #b5179e);
        }
        
        .btn-success {
            background: linear-gradient(90deg, #4ade80, #16a34a);
        }
        
        .btn-warning {
            background: linear-gradient(90deg, #f59e0b, #d97706);
        }
        
        /* File Upload */
        .file-upload {
            background: rgba(30, 30, 60, 0.8);
            border: 2px dashed #4361ee;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            margin: 20px 0;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .file-upload:hover {
            border-color: #4cc9f0;
            background: rgba(40, 40, 70, 0.8);
        }
        
        .file-upload.dragover {
            border-color: #4ade80;
            background: rgba(40, 70, 40, 0.8);
        }
        
        .file-list {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .file-item {
            background: rgba(20, 20, 40, 0.8);
            border-radius: 8px;
            padding: 10px 15px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            border-left: 4px solid #4361ee;
        }
        
        .file-item.required {
            border-left-color: #f59e0b;
        }
        
        .file-item.loaded {
            border-left-color: #4ade80;
        }
        
        .file-icon {
            margin-right: 10px;
            font-size: 1.5rem;
        }
        
        .file-info {
            flex: 1;
        }
        
        .file-name {
            font-weight: 600;
        }
        
        .file-size {
            font-size: 0.9rem;
            color: #a0a0ff;
        }
        
        .file-status {
            font-size: 0.8rem;
            padding: 3px 8px;
            border-radius: 10px;
            background: rgba(67, 97, 238, 0.2);
        }
        
        /* Waiting Room */
        .players-list {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            margin: 30px 0;
        }
        
        .player-card {
            background: rgba(30, 30, 60, 0.8);
            border-radius: 10px;
            padding: 20px;
            width: 200px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s;
        }
        
        .player-card.ready {
            border-color: #4ade80;
            box-shadow: 0 0 15px rgba(74, 222, 128, 0.3);
        }
        
        .player-card.host {
            border-color: #4cc9f0;
        }
        
        .player-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            margin: 0 auto 15px;
            background: linear-gradient(135deg, #4361ee, #3a0ca3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
        }
        
        .player-name {
            font-weight: 600;
            margin-bottom: 10px;
            color: #e0e0ff;
        }
        
        .player-status {
            font-size: 0.9rem;
            padding: 5px 10px;
            border-radius: 20px;
            display: inline-block;
        }
        
        .status-ready {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
        }
        
        .status-waiting {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
        }
        
        .status-downloading {
            background: rgba(67, 97, 238, 0.2);
            color: #4361ee;
        }
        
        /* Game Screen */
        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .game-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
        }
        
        .ui-panel {
            background: rgba(20, 20, 40, 0.8);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(76, 201, 240, 0.3);
            min-width: 200px;
            backdrop-filter: blur(5px);
            pointer-events: auto;
        }
        
        .mission-list {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(20, 20, 40, 0.8);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(76, 201, 240, 0.3);
            width: 300px;
            backdrop-filter: blur(5px);
        }
        
        .mission-item {
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
        }
        
        .mission-item.completed {
            color: #4ade80;
        }
        
        .mission-checkbox {
            margin-right: 10px;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 2px solid #4361ee;
            display: inline-block;
        }
        
        .mission-item.completed .mission-checkbox {
            background: #4ade80;
            border-color: #4ade80;
        }
        
        .extraction-timer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 20, 40, 0.8);
            border-radius: 10px;
            padding: 15px 25px;
            border: 1px solid rgba(76, 201, 240, 0.3);
            font-size: 1.3rem;
            font-weight: 600;
            color: #4cc9f0;
            text-align: center;
            backdrop-filter: blur(5px);
        }
        
        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 25, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .loading-progress {
            width: 80%;
            max-width: 400px;
            height: 20px;
            background: rgba(20, 20, 40, 0.8);
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
            border: 1px solid #4361ee;
        }
        
        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #4361ee, #4cc9f0);
            width: 0%;
            transition: width 0.3s;
            border-radius: 10px;
        }
        
        .loading-file {
            margin-top: 10px;
            color: #a0a0ff;
            font-size: 0.9rem;
            text-align: center;
        }
        
        .loading-speed {
            font-size: 0.8rem;
            color: #a0a0ff;
            margin-top: 5px;
        }
        
        /* Notifications */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 40, 0.95);
            border-radius: 10px;
            padding: 15px;
            border-left: 5px solid #4361ee;
            max-width: 350px;
            transform: translateX(400px);
            transition: transform 0.5s;
            z-index: 1000;
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        .notification-title {
            font-weight: 600;
            margin-bottom: 5px;
            color: #4cc9f0;
        }
        
        /* Code Display */
        .code-display {
            font-size: 3rem;
            font-weight: 800;
            letter-spacing: 10px;
            text-align: center;
            background: rgba(10, 10, 25, 0.8);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            color: #4ade80;
            border: 2px solid #4361ee;
        }
        
        /* Instructions */
        .instructions {
            background: rgba(20, 20, 40, 0.6);
            border-radius: 10px;
            padding: 20px;
            margin-top: 30px;
            border: 1px solid rgba(76, 201, 240, 0.2);
        }
        
        .instructions h3 {
            color: #4cc9f0;
            margin-bottom: 10px;
        }
        
        .instructions ul {
            padding-left: 20px;
        }
        
        .instructions li {
            margin-bottom: 8px;
            line-height: 1.5;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .title {
                font-size: 2.5rem;
            }
            
            .room-controls {
                padding: 20px;
            }
            
            .ui-panel, .mission-list {
                transform: scale(0.9);
                transform-origin: top left;
            }
        }
        
        /* Animations */
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
        
        /* Loading */
        .loader {
            border: 5px solid rgba(67, 97, 238, 0.3);
            border-top: 5px solid #4361ee;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        .loader-small {
            border: 3px solid rgba(67, 97, 238, 0.3);
            border-top: 3px solid #4361ee;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-left: 10px;
            vertical-align: middle;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- Main Menu Screen -->
    <div id="mainMenu" class="screen active">
        <h1 class="title">MISSION EXTRACTION</h1>
        <p class="subtitle">Local Network Co-op Tactical Operations</p>
        
        <div class="room-controls">
            <div class="input-group">
                <label for="playerName">Your Call Sign</label>
                <input type="text" id="playerName" placeholder="Enter your name" value="Operator" maxlength="12">
            </div>
            
            <button id="createRoomBtn" class="btn">CREATE ROOM</button>
            <button id="joinRoomBtn" class="btn btn-secondary">JOIN ROOM</button>
        </div>
        
        <div class="instructions">
            <h3>How to Play:</h3>
            <ul>
                <li><strong>Host:</strong> Creates room, uploads game assets (GLB/GLTF files)</li>
                <li><strong>Players:</strong> Join with room code, download assets from host</li>
                <li><strong>Missions:</strong> Eliminate enemies, secure objectives</li>
                <li><strong>Extraction:</strong> Meet at extraction point after 2 minutes</li>
                <li><strong>Win:</strong> Both players must extract together</li>
            </ul>
        </div>
    </div>
    
    <!-- Host Room Screen -->
    <div id="hostRoomScreen" class="screen">
        <h1 class="title">HOST ROOM</h1>
        <p class="subtitle">Upload game assets and create room</p>
        
        <div class="room-controls">
            <div class="input-group">
                <label>Required Game Assets</label>
                <p style="color: #a0a0ff; font-size: 0.9rem; margin-top: 5px;">
                    Upload these files from your computer:
                </p>
            </div>
            
            <div class="file-upload" id="fileDropZone">
                <div class="file-icon">üìÅ</div>
                <h3>Drag & Drop Game Files Here</h3>
                <p>or click to select files</p>
                <p style="font-size: 0.9rem; color: #a0a0ff; margin-top: 10px;">
                    Required: map.glb, player1.glb, player2.glb, enemy.glb
                </p>
                <input type="file" id="fileInput" multiple accept=".glb,.gltf" style="display: none;">
            </div>
            
            <div class="file-list" id="fileList">
                <!-- Files will be listed here -->
                <div class="file-item required">
                    <div class="file-icon">üó∫Ô∏è</div>
                    <div class="file-info">
                        <div class="file-name">map.glb</div>
                        <div class="file-size">Required - 3D Map File</div>
                    </div>
                    <div class="file-status" id="mapStatus">Missing</div>
                </div>
                <div class="file-item required">
                    <div class="file-icon">üë§</div>
                    <div class="file-info">
                        <div class="file-name">player1.glb</div>
                        <div class="file-size">Required - Player 1 Model</div>
                    </div>
                    <div class="file-status" id="player1Status">Missing</div>
                </div>
                <div class="file-item required">
                    <div class="file-icon">üë§</div>
                    <div class="file-info">
                        <div class="file-name">player2.glb</div>
                        <div class="file-size">Required - Player 2 Model</div>
                    </div>
                    <div class="file-status" id="player2Status">Missing</div>
                </div>
                <div class="file-item required">
                    <div class="file-icon">üëæ</div>
                    <div class="file-info">
                        <div class="file-name">enemy.glb</div>
                        <div class="file-size">Required - Enemy Model</div>
                    </div>
                    <div class="file-status" id="enemyStatus">Missing</div>
                </div>
            </div>
            
            <button id="createRoomWithAssets" class="btn btn-success" disabled>CREATE ROOM WITH ASSETS</button>
            <button id="backToMainFromHost" class="btn btn-secondary">BACK</button>
        </div>
    </div>
    
    <!-- Room Created Screen -->
    <div id="roomCreatedScreen" class="screen">
        <h1 class="title">ROOM CREATED</h1>
        <p class="subtitle">Share this code with other players on your local network</p>
        
        <div class="code-display" id="roomCode">----</div>
        
        <div class="room-controls">
            <p>Waiting for players to join...</p>
            <p style="color: #4cc9f0; margin: 10px 0;">
                <span id="connectedPlayers">0</span> player(s) connected
            </p>
            <div class="loader"></div>
            <button id="goToWaitingRoom" class="btn btn-success hidden">GO TO WAITING ROOM</button>
        </div>
    </div>
    
    <!-- Join Room Screen -->
    <div id="joinRoomScreen" class="screen">
        <h1 class="title">JOIN ROOM</h1>
        <p class="subtitle">Enter the 4-digit room code provided by the host</p>
        
        <div class="room-controls">
            <div class="input-group">
                <label for="joinCodeInput">Room Code</label>
                <input type="text" id="joinCodeInput" placeholder="Enter 4-digit code" maxlength="4" pattern="\d{4}">
            </div>
            
            <button id="joinWithCodeBtn" class="btn">JOIN</button>
            <button id="backToMainBtn" class="btn btn-secondary">BACK</button>
        </div>
    </div>
    
    <!-- Waiting Room Screen -->
    <div id="waitingRoomScreen" class="screen">
        <h1 class="title">WAITING ROOM</h1>
        <p class="subtitle" id="roomCodeDisplay">Room Code: ----</p>
        
        <div class="players-list" id="playersList">
            <!-- Player cards will be inserted here -->
        </div>
        
        <div class="room-controls">
            <div id="playerStatus">
                <div id="downloadStatus" class="hidden">
                    <p style="margin-bottom: 10px; color: #4cc9f0;">
                        <span id="downloadProgress">Downloading assets from host...</span>
                        <span class="loader-small"></span>
                    </p>
                    <div class="loading-progress">
                        <div class="loading-bar" id="downloadBar"></div>
                    </div>
                </div>
                
                <button id="readyBtn" class="btn hidden">READY</button>
                <p id="hostMessage" class="hidden">All players ready. You can start the mission.</p>
                <button id="startMissionBtn" class="btn btn-success hidden">LAUNCH MISSION</button>
            </div>
            <button id="leaveWaitingRoomBtn" class="btn btn-secondary">LEAVE ROOM</button>
        </div>
    </div>
    
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen hidden">
        <h1 class="title">LOADING GAME</h1>
        <div class="loading-progress">
            <div class="loading-bar" id="loadingBar"></div>
        </div>
        <div class="loading-file" id="loadingFile">Initializing game...</div>
        <div class="loader"></div>
    </div>
    
    <!-- Game Screen -->
    <div id="gameScreen" class="screen">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Game UI Overlay -->
        <div class="game-ui">
            <div class="ui-panel">
                <h3>OPERATOR STATUS</h3>
                <p>Player: <span id="uiPlayerName">---</span></p>
                <p>Health: <span id="uiHealth">100</span></p>
                <p>Enemies Eliminated: <span id="uiKills">0</span>/10</p>
                <p>Objectives: <span id="uiObjectives">0</span>/3</p>
            </div>
            
            <div class="ui-panel">
                <h3>TEAM STATUS</h3>
                <div id="teamStatus">
                    <!-- Team member status will be inserted here -->
                </div>
            </div>
        </div>
        
        <div class="extraction-timer">
            Extraction Available In: <span id="extractionTimer">02:00</span>
        </div>
        
        <div class="mission-list">
            <h3>ACTIVE MISSIONS</h3>
            <div class="mission-item" id="mission1">
                <div class="mission-checkbox"></div>
                <span>Eliminate 10 enemies (0/10)</span>
            </div>
            <div class="mission-item" id="mission2">
                <div class="mission-checkbox"></div>
                <span>Secure server room</span>
            </div>
            <div class="mission-item" id="mission3">
                <div class="mission-checkbox"></div>
                <span>Download intel data</span>
            </div>
            <div class="mission-item" id="mission4">
                <div class="mission-checkbox"></div>
                <span>Extract with partner</span>
            </div>
        </div>
    </div>
    
    <!-- Notification System -->
    <div id="notificationArea"></div>

    <!-- Three.js and Game Logic -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    
    <script>
        // Game State and Configuration
        const CONFIG = {
            ROOM_CODE_LENGTH: 4,
            MAX_PLAYERS: 4,
            EXTRACTION_TIME_MINUTES: 2,
            LOCAL_STORAGE_KEY: 'mission_extraction_rooms',
            REQUIRED_ASSETS: ['map', 'player1', 'player2', 'enemy'],
            CHUNK_SIZE: 16384 // 16KB chunks for file transfer
        };

        // Game State
        let gameState = {
            currentScreen: 'mainMenu',
            playerId: null,
            playerName: 'Operator',
            roomCode: null,
            isHost: false,
            isReady: false,
            peerConnections: {},
            dataChannels: {},
            players: {},
            gameStarted: false,
            assets: {
                map: null,
                player1: null,
                player2: null,
                enemy: null
            },
            assetFiles: {},
            missions: {
                enemiesKilled: 0,
                serverSecured: false,
                intelDownloaded: false,
                extractionReady: false
            },
            extractionTimer: CONFIG.EXTRACTION_TIME_MINUTES * 60,
            extractionAvailable: false,
            gameTime: 0
        };

        // Three.js variables
        let scene, camera, renderer, controls;
        let mapModel, player1Model, player2Model, enemyModel;
        let playerObjects = {};
        let enemyObjects = [];
        let extractionZone = null;

        // File transfer variables
        let fileTransfers = {};
        let receivedAssets = {};

        // DOM Elements
        const screens = {
            mainMenu: document.getElementById('mainMenu'),
            hostRoomScreen: document.getElementById('hostRoomScreen'),
            roomCreatedScreen: document.getElementById('roomCreatedScreen'),
            joinRoomScreen: document.getElementById('joinRoomScreen'),
            waitingRoomScreen: document.getElementById('waitingRoomScreen'),
            gameScreen: document.getElementById('gameScreen')
        };

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            initEventListeners();
            generatePlayerId();
            loadPlayerName();
        });

        function initEventListeners() {
            // Main Menu
            document.getElementById('createRoomBtn').addEventListener('click', () => showScreen('hostRoomScreen'));
            document.getElementById('joinRoomBtn').addEventListener('click', () => showScreen('joinRoomScreen'));
            
            // Host Room Screen
            document.getElementById('fileInput').addEventListener('change', handleFileSelect);
            document.getElementById('fileDropZone').addEventListener('click', () => document.getElementById('fileInput').click());
            document.getElementById('createRoomWithAssets').addEventListener('click', createRoomWithAssets);
            document.getElementById('backToMainFromHost').addEventListener('click', showMainMenu);
            
            // Drag and drop
            const dropZone = document.getElementById('fileDropZone');
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });
            
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('dragover');
            });
            
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                handleFileSelect({ target: { files: e.dataTransfer.files } });
            });
            
            // Join Room Screen
            document.getElementById('joinWithCodeBtn').addEventListener('click', joinRoom);
            document.getElementById('backToMainBtn').addEventListener('click', showMainMenu);
            document.getElementById('joinCodeInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') joinRoom();
            });
            
            // Waiting Room
            document.getElementById('readyBtn').addEventListener('click', toggleReady);
            document.getElementById('startMissionBtn').addEventListener('click', startGame);
            document.getElementById('leaveWaitingRoomBtn').addEventListener('click', leaveWaitingRoom);
            document.getElementById('goToWaitingRoom').addEventListener('click', goToWaitingRoom);
            
            // Player name input
            document.getElementById('playerName').addEventListener('input', (e) => {
                gameState.playerName = e.target.value || 'Operator';
                localStorage.setItem('playerName', gameState.playerName);
            });
        }

        function generatePlayerId() {
            gameState.playerId = 'player_' + Math.random().toString(36).substr(2, 9);
        }

        function loadPlayerName() {
            const savedName = localStorage.getItem('playerName');
            if (savedName) {
                gameState.playerName = savedName;
                document.getElementById('playerName').value = savedName;
            }
        }

        function showScreen(screenName) {
            Object.values(screens).forEach(screen => {
                screen.classList.remove('active');
            });
            
            screens[screenName].classList.add('active');
            gameState.currentScreen = screenName;
        }

        function showMainMenu() {
            showScreen('mainMenu');
        }

        function showLoadingScreen(show = true) {
            const loadingScreen = document.getElementById('loadingScreen');
            if (show) {
                loadingScreen.classList.remove('hidden');
            } else {
                loadingScreen.classList.add('hidden');
            }
        }

        function updateLoadingProgress(percent, message) {
            document.getElementById('loadingBar').style.width = percent + '%';
            document.getElementById('loadingFile').textContent = message;
        }

        // File Handling
        function handleFileSelect(event) {
            const files = Array.from(event.target.files);
            let allRequiredFound = true;
            
            files.forEach(file => {
                const fileName = file.name.toLowerCase();
                let assetType = null;
                
                if (fileName.includes('map')) assetType = 'map';
                else if (fileName.includes('player1')) assetType = 'player1';
                else if (fileName.includes('player2')) assetType = 'player2';
                else if (fileName.includes('enemy')) assetType = 'enemy';
                
                if (assetType) {
                    gameState.assetFiles[assetType] = file;
                    updateFileStatus(assetType, 'loaded', formatFileSize(file.size));
                }
            });
            
            // Check if all required files are present
            CONFIG.REQUIRED_ASSETS.forEach(asset => {
                if (!gameState.assetFiles[asset]) {
                    allRequiredFound = false;
                }
            });
            
            // Enable/disable create room button
            document.getElementById('createRoomWithAssets').disabled = !allRequiredFound;
            
            if (allRequiredFound) {
                showNotification('All Assets Ready', 'All required game files are loaded. You can now create the room.');
            }
        }

        function updateFileStatus(assetType, status, size = '') {
            const element = document.getElementById(assetType + 'Status');
            const fileItem = document.querySelector(`#fileList .file-item:nth-child(${CONFIG.REQUIRED_ASSETS.indexOf(assetType) + 1})`);
            
            element.textContent = status;
            
            if (status === 'loaded') {
                element.style.background = 'rgba(74, 222, 128, 0.2)';
                element.style.color = '#4ade80';
                fileItem.classList.add('loaded');
                
                if (size) {
                    const sizeElement = fileItem.querySelector('.file-size');
                    sizeElement.textContent = size;
                }
            } else if (status === 'Missing') {
                element.style.background = 'rgba(245, 158, 11, 0.2)';
                element.style.color = '#f59e0b';
                fileItem.classList.remove('loaded');
            }
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Room Creation with Assets
        function createRoomWithAssets() {
            // Generate room code
            gameState.roomCode = Math.floor(1000 + Math.random() * 9000).toString();
            gameState.isHost = true;
            
            // Create room data
            const roomData = {
                code: gameState.roomCode,
                hostId: gameState.playerId,
                hostName: gameState.playerName,
                players: [{
                    id: gameState.playerId,
                    name: gameState.playerName,
                    isReady: false,
                    isHost: true,
                    assetsLoaded: true
                }],
                assets: CONFIG.REQUIRED_ASSETS.reduce((acc, asset) => {
                    acc[asset] = gameState.assetFiles[asset] ? {
                        name: gameState.assetFiles[asset].name,
                        size: gameState.assetFiles[asset].size,
                        type: gameState.assetFiles[asset].type
                    } : null;
                    return acc;
                }, {}),
                gameStarted: false,
                lastUpdated: Date.now()
            };
            
            saveRoomData(roomData);
            
            // Update UI
            document.getElementById('roomCode').textContent = gameState.roomCode;
            showScreen('roomCreatedScreen');
            
            // Start peer-to-peer discovery
            setupHostPeer();
            checkForPlayers();
        }

        function setupHostPeer() {
            // Host listens for connections from players
            // In a real implementation, we'd use WebRTC or WebSocket
            // For local network, we'll use localStorage polling
        }

        function checkForPlayers() {
            const interval = setInterval(() => {
                const roomData = getRoomData(gameState.roomCode);
                
                if (!roomData) {
                    clearInterval(interval);
                    return;
                }
                
                // Update connected players count
                document.getElementById('connectedPlayers').textContent = (roomData.players.length - 1);
                
                // If there are other players, show waiting room button
                if (roomData.players.length >= 2) {
                    document.getElementById('goToWaitingRoom').classList.remove('hidden');
                    clearInterval(interval);
                }
                
                // Check if any player needs assets
                roomData.players.forEach(player => {
                    if (player.id !== gameState.playerId && !player.assetsLoaded) {
                        // Send assets to this player
                        sendAssetsToPlayer(player.id);
                    }
                });
            }, 1000);
        }

        function goToWaitingRoom() {
            const roomData = getRoomData(gameState.roomCode);
            if (!roomData) return;
            
            gameState.players = roomData.players.reduce((acc, player) => {
                acc[player.id] = player;
                return acc;
            }, {});
            
            document.getElementById('roomCodeDisplay').textContent = `Room Code: ${gameState.roomCode}`;
            updatePlayersList();
            showScreen('waitingRoomScreen');
            pollRoomUpdates();
        }

        // Join Room
        function joinRoom() {
            const codeInput = document.getElementById('joinCodeInput');
            const code = codeInput.value.trim();
            
            if (code.length !== CONFIG.ROOM_CODE_LENGTH || !/^\d+$/.test(code)) {
                showNotification('Invalid Code', 'Please enter a valid 4-digit room code.');
                return;
            }
            
            gameState.roomCode = code;
            
            const roomData = getRoomData(code);
            
            if (!roomData) {
                showNotification('Room Not Found', 'No room found with that code.');
                return;
            }
            
            if (roomData.gameStarted) {
                showNotification('Game In Progress', 'This game has already started.');
                return;
            }
            
            // Add player to room
            const playerData = {
                id: gameState.playerId,
                name: gameState.playerName,
                isReady: false,
                isHost: false,
                assetsLoaded: false
            };
            
            roomData.players.push(playerData);
            roomData.lastUpdated = Date.now();
            saveRoomData(roomData);
            
            // Update game state
            gameState.isHost = false;
            gameState.players = roomData.players.reduce((acc, player) => {
                acc[player.id] = player;
                return acc;
            }, {});
            
            // Show waiting room
            document.getElementById('roomCodeDisplay').textContent = `Room Code: ${gameState.roomCode}`;
            updatePlayersList();
            showScreen('waitingRoomScreen');
            
            // Show download status
            document.getElementById('downloadStatus').classList.remove('hidden');
            document.getElementById('readyBtn').classList.add('hidden');
            
            // Start downloading assets
            downloadAssetsFromHost(roomData.assets);
            pollRoomUpdates();
        }

        function downloadAssetsFromHost(assets) {
            showNotification('Downloading Assets', 'Downloading game assets from host...');
            
            // Simulate asset download (in real implementation, would use WebRTC)
            let totalSize = 0;
            let downloadedSize = 0;
            
            CONFIG.REQUIRED_ASSETS.forEach(asset => {
                if (assets[asset]) {
                    totalSize += assets[asset].size;
                }
            });
            
            // Simulate download progress
            const simulateDownload = () => {
                if (downloadedSize < totalSize) {
                    downloadedSize += totalSize / 100; // 1% increments
                    const percent = Math.min(100, (downloadedSize / totalSize) * 100);
                    
                    document.getElementById('downloadBar').style.width = percent + '%';
                    document.getElementById('downloadProgress').textContent = 
                        `Downloading assets: ${Math.round(percent)}%`;
                    
                    // Simulate different file downloads
                    if (percent >= 25 && !receivedAssets.map) {
                        receivedAssets.map = true;
                        showNotification('Map Downloaded', 'Map asset downloaded successfully.');
                    }
                    if (percent >= 50 && !receivedAssets.player1) {
                        receivedAssets.player1 = true;
                        showNotification('Player Model Downloaded', 'Player 1 model downloaded.');
                    }
                    if (percent >= 75 && !receivedAssets.player2) {
                        receivedAssets.player2 = true;
                        showNotification('Player Model Downloaded', 'Player 2 model downloaded.');
                    }
                    if (percent >= 95 && !receivedAssets.enemy) {
                        receivedAssets.enemy = true;
                        showNotification('Enemy Model Downloaded', 'Enemy model downloaded.');
                    }
                    
                    if (percent >= 100) {
                        // All assets downloaded
                        document.getElementById('downloadStatus').classList.add('hidden');
                        document.getElementById('readyBtn').classList.remove('hidden');
                        
                        // Update room data
                        const roomData = getRoomData(gameState.roomCode);
                        if (roomData) {
                            const playerIndex = roomData.players.findIndex(p => p.id === gameState.playerId);
                            if (playerIndex !== -1) {
                                roomData.players[playerIndex].assetsLoaded = true;
                                saveRoomData(roomData);
                            }
                        }
                        
                        showNotification('Assets Ready', 'All game assets downloaded. You can now ready up.');
                        return;
                    }
                    
                    setTimeout(simulateDownload, 100);
                }
            };
            
            simulateDownload();
        }

        function sendAssetsToPlayer(playerId) {
            // In a real implementation, this would send files via WebRTC data channels
            console.log(`Would send assets to player ${playerId}`);
        }

        // Room Management
        function saveRoomData(roomData) {
            const rooms = JSON.parse(localStorage.getItem(CONFIG.LOCAL_STORAGE_KEY) || '{}');
            rooms[roomData.code] = roomData;
            localStorage.setItem(CONFIG.LOCAL_STORAGE_KEY, JSON.stringify(rooms));
        }

        function getRoomData(code) {
            const rooms = JSON.parse(localStorage.getItem(CONFIG.LOCAL_STORAGE_KEY) || '{}');
            return rooms[code];
        }

        function deleteRoomData(code) {
            const rooms = JSON.parse(localStorage.getItem(CONFIG.LOCAL_STORAGE_KEY) || '{}');
            delete rooms[code];
            localStorage.setItem(CONFIG.LOCAL_STORAGE_KEY, JSON.stringify(rooms));
        }

        function pollRoomUpdates() {
            const interval = setInterval(() => {
                const roomData = getRoomData(gameState.roomCode);
                
                if (!roomData) {
                    clearInterval(interval);
                    showNotification('Room Closed', 'The host has closed the room.');
                    showMainMenu();
                    return;
                }
                
                // Update players
                gameState.players = roomData.players.reduce((acc, player) => {
                    acc[player.id] = player;
                    return acc;
                }, {});
                
                updatePlayersList();
                
                // Check if all players are ready and have assets
                const allReady = roomData.players.every(player => player.isReady && player.assetsLoaded);
                const hostElement = document.getElementById('hostMessage');
                const startBtn = document.getElementById('startMissionBtn');
                
                if (gameState.isHost && allReady && roomData.players.length >= 2) {
                    hostElement.classList.remove('hidden');
                    startBtn.classList.remove('hidden');
                } else {
                    hostElement.classList.add('hidden');
                    startBtn.classList.add('hidden');
                }
                
                // If game started, initialize game
                if (roomData.gameStarted && !gameState.gameStarted) {
                    clearInterval(interval);
                    gameState.gameStarted = true;
                    loadGameAssets();
                }
            }, 1000);
        }

        function updatePlayersList() {
            const playersList = document.getElementById('playersList');
            playersList.innerHTML = '';
            
            Object.values(gameState.players).forEach(player => {
                const playerCard = document.createElement('div');
                playerCard.className = 'player-card';
                if (player.isReady) playerCard.classList.add('ready');
                if (player.isHost) playerCard.classList.add('host');
                
                let status = player.isReady ? 'READY' : 'WAITING';
                if (!player.assetsLoaded && !player.isHost) {
                    status = 'DOWNLOADING';
                }
                
                playerCard.innerHTML = `
                    <div class="player-avatar">${player.name.charAt(0).toUpperCase()}</div>
                    <div class="player-name">${player.name} ${player.isHost ? 'üëë' : ''}</div>
                    <div class="player-status ${status === 'READY' ? 'status-ready' : status === 'DOWNLOADING' ? 'status-downloading' : 'status-waiting'}">
                        ${status}
                    </div>
                `;
                
                playersList.appendChild(playerCard);
            });
        }

        function toggleReady() {
            const roomData = getRoomData(gameState.roomCode);
            if (!roomData) return;
            
            const playerIndex = roomData.players.findIndex(p => p.id === gameState.playerId);
            if (playerIndex !== -1) {
                roomData.players[playerIndex].isReady = !roomData.players[playerIndex].isReady;
                gameState.isReady = roomData.players[playerIndex].isReady;
                roomData.lastUpdated = Date.now();
                
                saveRoomData(roomData);
                updatePlayersList();
                
                const readyBtn = document.getElementById('readyBtn');
                readyBtn.textContent = gameState.isReady ? 'NOT READY' : 'READY';
                readyBtn.classList.toggle('btn-secondary', gameState.isReady);
            }
        }

        function startGame() {
            const roomData = getRoomData(gameState.roomCode);
            if (!roomData || !gameState.isHost) return;
            
            roomData.gameStarted = true;
            roomData.lastUpdated = Date.now();
            saveRoomData(roomData);
            
            loadGameAssets();
        }

        function leaveWaitingRoom() {
            const roomData = getRoomData(gameState.roomCode);
            if (roomData) {
                roomData.players = roomData.players.filter(p => p.id !== gameState.playerId);
                
                if (roomData.players.length === 0 || (gameState.isHost && roomData.players.length > 0)) {
                    deleteRoomData(gameState.roomCode);
                } else {
                    saveRoomData(roomData);
                }
            }
            
            gameState.roomCode = null;
            gameState.isHost = false;
            gameState.isReady = false;
            gameState.players = {};
            gameState.assetFiles = {};
            
            showMainMenu();
        }

        // Game Initialization
        function loadGameAssets() {
            showLoadingScreen(true);
            updateLoadingProgress(0, 'Loading game assets...');
            
            // Simulate loading assets
            const assetsToLoad = CONFIG.REQUIRED_ASSETS;
            let loadedCount = 0;
            
            const loadNextAsset = () => {
                if (loadedCount < assetsToLoad.length) {
                    const asset = assetsToLoad[loadedCount];
                    const percent = (loadedCount / assetsToLoad.length) * 100;
                    
                    updateLoadingProgress(percent, `Loading ${asset}.glb...`);
                    
                    // Simulate loading time
                    setTimeout(() => {
                        loadedCount++;
                        showNotification('Asset Loaded', `${asset}.glb loaded successfully`);
                        loadNextAsset();
                    }, 500);
                } else {
                    updateLoadingProgress(100, 'All assets loaded!');
                    setTimeout(() => {
                        showLoadingScreen(false);
                        initializeGame();
                    }, 1000);
                }
            };
            
            loadNextAsset();
        }

        function initializeGame() {
            showScreen('gameScreen');
            
            // Update UI
            document.getElementById('uiPlayerName').textContent = gameState.playerName;
            updateTeamStatus();
            
            // Initialize Three.js
            initThreeJS();
            startGameLoop();
            startExtractionTimer();
            initializeMissions();
            
            // Start game simulation
            simulateGameEvents();
        }

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 20);
            
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('gameCanvas'), 
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Create game world
            createGameWorld();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }

        function createGameWorld() {
            // Ground
            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2a2a4a,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Buildings
            const buildings = [
                { x: -30, z: 20, w: 15, h: 10, d: 15, color: 0x3a3a6a, name: 'Server Room' },
                { x: 25, z: -25, w: 12, h: 8, d: 12, color: 0x5a3a3a, name: 'Intel Building' },
                { x: -20, z: -30, w: 10, h: 6, d: 10, color: 0x3a5a5a, name: 'Warehouse' },
                { x: 30, z: 20, w: 8, h: 5, d: 8, color: 0x5a5a3a, name: 'Guard Post' }
            ];
            
            buildings.forEach(building => {
                const geometry = new THREE.BoxGeometry(building.w, building.h, building.d);
                const material = new THREE.MeshStandardMaterial({ 
                    color: building.color,
                    roughness: 0.7
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(building.x, building.h / 2, building.z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
                
                // Add label
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                ctx.fillStyle = 'rgba(20, 20, 40, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.font = 'bold 20px Arial';
                ctx.fillStyle = '#e0e0ff';
                ctx.textAlign = 'center';
                ctx.fillText(building.name, canvas.width/2, canvas.height/2 + 8);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(building.x, building.h + 2, building.z);
                sprite.scale.set(10, 2.5, 1);
                scene.add(sprite);
            });
            
            // Create players
            createPlayers();
            
            // Create enemies
            createEnemies();
            
            // Create extraction zone
            createExtractionZone();
        }

        function createPlayers() {
            const playerGeometry = new THREE.CapsuleGeometry(0.5, 2, 4, 8);
            const playerColors = [0x4361ee, 0xf72585, 0x4ade80, 0xf59e0b];
            
            // Current player
            const playerMaterial = new THREE.MeshStandardMaterial({ 
                color: playerColors[0],
                emissive: playerColors[0],
                emissiveIntensity: 0.2
            });
            const playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
            playerMesh.position.set(0, 1, 0);
            playerMesh.castShadow = true;
            scene.add(playerMesh);
            
            playerObjects[gameState.playerId] = {
                mesh: playerMesh,
                name: gameState.playerName,
                health: 100,
                position: { x: 0, y: 1, z: 0 }
            };
            
            // Other players
            const otherPlayers = Object.values(gameState.players).filter(p => p.id !== gameState.playerId);
            otherPlayers.forEach((player, index) => {
                const material = new THREE.MeshStandardMaterial({ 
                    color: playerColors[(index + 1) % playerColors.length],
                    emissive: playerColors[(index + 1) % playerColors.length],
                    emissiveIntensity: 0.2
                });
                const mesh = new THREE.Mesh(playerGeometry, material);
                
                const positions = [
                    { x: 20, z: 0 },
                    { x: -20, z: 0 },
                    { x: 0, z: 20 }
                ];
                const pos = positions[index] || { x: 10, z: 10 };
                
                mesh.position.set(pos.x, 1, pos.z);
                mesh.castShadow = true;
                scene.add(mesh);
                
                playerObjects[player.id] = {
                    mesh: mesh,
                    name: player.name,
                    health: 100,
                    position: { x: pos.x, y: 1, z: pos.z }
                };
            });
            
            addPlayerLabels();
        }

        function addPlayerLabels() {
            Object.values(playerObjects).forEach(playerObj => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                
                ctx.fillStyle = 'rgba(20, 20, 40, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.font = 'bold 20px Arial';
                ctx.fillStyle = '#e0e0ff';
                ctx.textAlign = 'center';
                ctx.fillText(playerObj.name, canvas.width/2, canvas.height/2);
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(material);
                sprite.position.set(0, 3, 0);
                sprite.scale.set(5, 1.25, 1);
                
                playerObj.mesh.add(sprite);
                playerObj.label = sprite;
            });
        }

        function createEnemies() {
            const enemyGeometry = new THREE.ConeGeometry(0.6, 2, 8);
            const enemyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xaa3333,
                emissive: 0xaa3333,
                emissiveIntensity: 0.1
            });
            
            for (let i = 0; i < 12; i++) {
                const enemyMesh = new THREE.Mesh(enemyGeometry, enemyMaterial);
                
                let x, z;
                if (i < 4) {
                    x = -30 + (Math.random() - 0.5) * 10;
                    z = 20 + (Math.random() - 0.5) * 10;
                } else if (i < 8) {
                    x = 25 + (Math.random() - 0.5) * 10;
                    z = -25 + (Math.random() - 0.5) * 10;
                } else {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 15 + Math.random() * 20;
                    x = Math.cos(angle) * radius;
                    z = Math.sin(angle) * radius;
                }
                
                enemyMesh.position.set(x, 1, z);
                enemyMesh.castShadow = true;
                scene.add(enemyMesh);
                
                enemyObjects.push({
                    mesh: enemyMesh,
                    health: 100,
                    position: { x, y: 1, z },
                    alive: true
                });
            }
        }

        function createExtractionZone() {
            const extractionGeometry = new THREE.CylinderGeometry(8, 8, 0.2, 32);
            const extractionMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4ade80,
                emissive: 0x4ade80,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.5
            });
            
            extractionZone = new THREE.Mesh(extractionGeometry, extractionMaterial);
            extractionZone.position.set(0, 0.1, 0);
            scene.add(extractionZone);
            
            extractionZone.userData.pulseDirection = 1;
            extractionZone.userData.originalOpacity = 0.5;
        }

        function startExtractionTimer() {
            const timerElement = document.getElementById('extractionTimer');
            
            const timerInterval = setInterval(() => {
                gameState.extractionTimer--;
                
                const minutes = Math.floor(gameState.extractionTimer / 60);
                const seconds = gameState.extractionTimer % 60;
                
                timerElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                if (gameState.extractionTimer <= 30) {
                    timerElement.classList.add('pulse');
                }
                
                if (gameState.extractionTimer <= 0) {
                    clearInterval(timerInterval);
                    gameState.extractionAvailable = true;
                    timerElement.textContent = 'EXTRACTION READY';
                    showNotification('Extraction Available', 'Meet your partner at the extraction zone!');
                    document.getElementById('mission4').classList.remove('hidden');
                }
            }, 1000);
        }

        function initializeMissions() {
            window.checkEnemyKill = function() {
                gameState.missions.enemiesKilled++;
                document.getElementById('uiKills').textContent = gameState.missions.enemiesKilled;
                
                const missionElement = document.getElementById('mission1');
                missionElement.querySelector('span').textContent = 
                    `Eliminate 10 enemies (${gameState.missions.enemiesKilled}/10)`;
                
                if (gameState.missions.enemiesKilled >= 10) {
                    missionElement.classList.add('completed');
                    showNotification('Mission Complete', 'Enemy elimination objective completed!');
                }
            };
            
            window.secureServerRoom = function() {
                if (!gameState.missions.serverSecured) {
                    gameState.missions.serverSecured = true;
                    document.getElementById('mission2').classList.add('completed');
                    updateObjectivesCount();
                    showNotification('Server Secured', 'Server room has been secured!');
                }
            };
            
            window.downloadIntel = function() {
                if (!gameState.missions.intelDownloaded) {
                    gameState.missions.intelDownloaded = true;
                    document.getElementById('mission3').classList.add('completed');
                    updateObjectivesCount();
                    showNotification('Intel Downloaded', 'Critical intelligence data acquired!');
                }
            };
            
            function updateObjectivesCount() {
                const count = (gameState.missions.serverSecured ? 1 : 0) + 
                             (gameState.missions.intelDownloaded ? 1 : 0);
                document.getElementById('uiObjectives').textContent = count;
            }
            
            // Demo controls
            document.addEventListener('keydown', (e) => {
                if (e.key === '1') window.checkEnemyKill();
                if (e.key === '2') window.secureServerRoom();
                if (e.key === '3') window.downloadIntel();
                if (e.key === '4' && gameState.extractionAvailable) {
                    document.getElementById('mission4').classList.add('completed');
                    showNotification('Extraction Complete', 'Mission accomplished! Well done, team.');
                }
            });
            
            showNotification('Controls', 'Press 1-4 to simulate mission progress');
        }

        function updateTeamStatus() {
            const teamStatus = document.getElementById('teamStatus');
            teamStatus.innerHTML = '';
            
            Object.values(playerObjects).forEach(player => {
                const div = document.createElement('div');
                div.className = 'team-member';
                div.innerHTML = `
                    <strong>${player.name}</strong><br>
                    Health: ${player.health}<br>
                    Status: ${player.health > 0 ? 'ACTIVE' : 'DOWN'}
                `;
                teamStatus.appendChild(div);
            });
        }

        function startGameLoop() {
            function animate() {
                requestAnimationFrame(animate);
                
                gameState.gameTime += 0.016;
                
                // Pulse extraction zone
                if (extractionZone) {
                    extractionZone.material.opacity += 0.02 * extractionZone.userData.pulseDirection;
                    if (extractionZone.material.opacity >= 0.7 || extractionZone.material.opacity <= 0.3) {
                        extractionZone.userData.pulseDirection *= -1;
                    }
                }
                
                // Rotate enemies
                enemyObjects.forEach(enemy => {
                    if (enemy.alive) {
                        enemy.mesh.rotation.y += 0.01;
                    }
                });
                
                // Rotate players
                Object.values(playerObjects).forEach(player => {
                    player.mesh.rotation.y += 0.005;
                });
                
                renderer.render(scene, camera);
            }
            
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function simulateGameEvents() {
            // Simulate enemy kills
            let killCount = 0;
            const killInterval = setInterval(() => {
                if (killCount < 10 && gameState.gameStarted) {
                    window.checkEnemyKill();
                    killCount++;
                    
                    // Random damage to players
                    Object.values(playerObjects).forEach(player => {
                        if (Math.random() > 0.7 && player.health > 0) {
                            player.health -= Math.floor(Math.random() * 20) + 5;
                            if (player.health < 0) player.health = 0;
                            document.getElementById('uiHealth').textContent = playerObjects[gameState.playerId].health;
                            updateTeamStatus();
                        }
                    });
                } else {
                    clearInterval(killInterval);
                }
            }, 3000);
            
            // Simulate mission completions
            setTimeout(() => {
                if (gameState.gameStarted) window.secureServerRoom();
            }, 8000);
            
            setTimeout(() => {
                if (gameState.gameStarted) window.downloadIntel();
            }, 15000);
        }

        function showNotification(title, message, duration = 5000) {
            const notificationArea = document.getElementById('notificationArea');
            
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.innerHTML = `
                <div class="notification-title">${title}</div>
                <div class="notification-message">${message}</div>
            `;
            
            notificationArea.appendChild(notification);
            
            setTimeout(() => notification.classList.add('show'), 10);
            
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 500);
            }, duration);
        }
    </script>
</body>
</html>
