<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mission Extraction - Local Network Multiplayer</title>
    <style>
        /* [Le CSS reste exactement le mÃªme] */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0c0c1d 0%, #1a1a2e 100%);
            color: #e0e0ff;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        /* ... [Tout le CSS prÃ©cÃ©dent reste identique] ... */
    </style>
</head>
<body>
    <!-- Main Menu Screen -->
    <div id="mainMenu" class="screen active">
        <!-- [Identique] -->
    </div>
    
    <!-- Host Room Screen -->
    <div id="hostRoomScreen" class="screen">
        <!-- [Identique] -->
    </div>
    
    <!-- Room Created Screen -->
    <div id="roomCreatedScreen" class="screen">
        <!-- [Identique] -->
    </div>
    
    <!-- Join Room Screen -->
    <div id="joinRoomScreen" class="screen">
        <!-- [Identique] -->
    </div>
    
    <!-- Waiting Room Screen -->
    <div id="waitingRoomScreen" class="screen">
        <h1 class="title">WAITING ROOM</h1>
        <p class="subtitle" id="roomCodeDisplay">Room Code: ----</p>
        
        <div class="players-list" id="playersList">
            <!-- Player cards will be inserted here -->
        </div>
        
        <div class="room-controls">
            <div id="playerStatus">
                <div id="downloadStatus" class="hidden">
                    <p style="margin-bottom: 10px; color: #4cc9f0;">
                        <span id="downloadProgress">Downloading assets from host...</span>
                        <span class="loader-small"></span>
                    </p>
                    <div class="loading-progress">
                        <div class="loading-bar" id="downloadBar"></div>
                    </div>
                </div>
                
                <!-- Le bouton READY est maintenant visible pour TOUS les joueurs -->
                <button id="readyBtn" class="btn">READY</button>
                
                <!-- Message et bouton seulement pour l'hÃ´te quand tout le monde est prÃªt -->
                <div id="hostControls" class="hidden">
                    <p id="hostMessage" style="margin: 15px 0; color: #4ade80; text-align: center;">
                        All players are ready!
                    </p>
                    <button id="startMissionBtn" class="btn btn-success">LAUNCH MISSION</button>
                </div>
            </div>
            <button id="leaveWaitingRoomBtn" class="btn btn-secondary">LEAVE ROOM</button>
        </div>
    </div>
    
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen hidden">
        <!-- [Identique] -->
    </div>
    
    <!-- Game Screen -->
    <div id="gameScreen" class="screen">
        <!-- [Identique] -->
    </div>
    
    <!-- Notification System -->
    <div id="notificationArea"></div>

    <!-- Three.js and Game Logic -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    
    <script>
        // Game State and Configuration
        const CONFIG = {
            ROOM_CODE_LENGTH: 4,
            MAX_PLAYERS: 4,
            EXTRACTION_TIME_MINUTES: 2,
            LOCAL_STORAGE_KEY: 'mission_extraction_rooms',
            REQUIRED_ASSETS: ['map', 'player1', 'player2', 'enemy'],
            CHUNK_SIZE: 16384
        };

        // Game State
        let gameState = {
            currentScreen: 'mainMenu',
            playerId: null,
            playerName: 'Operator',
            roomCode: null,
            isHost: false,
            isReady: false,
            peerConnections: {},
            dataChannels: {},
            players: {},
            gameStarted: false,
            assets: {
                map: null,
                player1: null,
                player2: null,
                enemy: null
            },
            assetFiles: {},
            missions: {
                enemiesKilled: 0,
                serverSecured: false,
                intelDownloaded: false,
                extractionReady: false
            },
            extractionTimer: CONFIG.EXTRACTION_TIME_MINUTES * 60,
            extractionAvailable: false,
            gameTime: 0
        };

        // Three.js variables
        let scene, camera, renderer, controls;
        let mapModel, player1Model, player2Model, enemyModel;
        let playerObjects = {};
        let enemyObjects = [];
        let extractionZone = null;

        // File transfer variables
        let fileTransfers = {};
        let receivedAssets = {};

        // DOM Elements
        const screens = {
            mainMenu: document.getElementById('mainMenu'),
            hostRoomScreen: document.getElementById('hostRoomScreen'),
            roomCreatedScreen: document.getElementById('roomCreatedScreen'),
            joinRoomScreen: document.getElementById('joinRoomScreen'),
            waitingRoomScreen: document.getElementById('waitingRoomScreen'),
            gameScreen: document.getElementById('gameScreen')
        };

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            initEventListeners();
            generatePlayerId();
            loadPlayerName();
        });

        function initEventListeners() {
            // Main Menu
            document.getElementById('createRoomBtn').addEventListener('click', () => showScreen('hostRoomScreen'));
            document.getElementById('joinRoomBtn').addEventListener('click', () => showScreen('joinRoomScreen'));
            
            // Host Room Screen
            document.getElementById('fileInput').addEventListener('change', handleFileSelect);
            document.getElementById('fileDropZone').addEventListener('click', () => document.getElementById('fileInput').click());
            document.getElementById('createRoomWithAssets').addEventListener('click', createRoomWithAssets);
            document.getElementById('backToMainFromHost').addEventListener('click', showMainMenu);
            
            // Drag and drop
            const dropZone = document.getElementById('fileDropZone');
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });
            
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('dragover');
            });
            
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                handleFileSelect({ target: { files: e.dataTransfer.files } });
            });
            
            // Join Room Screen
            document.getElementById('joinWithCodeBtn').addEventListener('click', joinRoom);
            document.getElementById('backToMainBtn').addEventListener('click', showMainMenu);
            document.getElementById('joinCodeInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') joinRoom();
            });
            
            // Waiting Room
            document.getElementById('readyBtn').addEventListener('click', toggleReady);
            document.getElementById('startMissionBtn').addEventListener('click', startGame);
            document.getElementById('leaveWaitingRoomBtn').addEventListener('click', leaveWaitingRoom);
            document.getElementById('goToWaitingRoom').addEventListener('click', goToWaitingRoom);
            
            // Player name input
            document.getElementById('playerName').addEventListener('input', (e) => {
                gameState.playerName = e.target.value || 'Operator';
                localStorage.setItem('playerName', gameState.playerName);
            });
        }

        function generatePlayerId() {
            gameState.playerId = 'player_' + Math.random().toString(36).substr(2, 9);
        }

        function loadPlayerName() {
            const savedName = localStorage.getItem('playerName');
            if (savedName) {
                gameState.playerName = savedName;
                document.getElementById('playerName').value = savedName;
            }
        }

        function showScreen(screenName) {
            Object.values(screens).forEach(screen => {
                screen.classList.remove('active');
            });
            
            screens[screenName].classList.add('active');
            gameState.currentScreen = screenName;
        }

        function showMainMenu() {
            showScreen('mainMenu');
        }

        function showLoadingScreen(show = true) {
            const loadingScreen = document.getElementById('loadingScreen');
            if (show) {
                loadingScreen.classList.remove('hidden');
            } else {
                loadingScreen.classList.add('hidden');
            }
        }

        function updateLoadingProgress(percent, message) {
            document.getElementById('loadingBar').style.width = percent + '%';
            document.getElementById('loadingFile').textContent = message;
        }

        // File Handling
        function handleFileSelect(event) {
            const files = Array.from(event.target.files);
            let allRequiredFound = true;
            
            files.forEach(file => {
                const fileName = file.name.toLowerCase();
                let assetType = null;
                
                if (fileName.includes('map')) assetType = 'map';
                else if (fileName.includes('player1')) assetType = 'player1';
                else if (fileName.includes('player2')) assetType = 'player2';
                else if (fileName.includes('enemy')) assetType = 'enemy';
                
                if (assetType) {
                    gameState.assetFiles[assetType] = file;
                    updateFileStatus(assetType, 'loaded', formatFileSize(file.size));
                }
            });
            
            // Check if all required files are present
            CONFIG.REQUIRED_ASSETS.forEach(asset => {
                if (!gameState.assetFiles[asset]) {
                    allRequiredFound = false;
                }
            });
            
            // Enable/disable create room button
            document.getElementById('createRoomWithAssets').disabled = !allRequiredFound;
            
            if (allRequiredFound) {
                showNotification('All Assets Ready', 'All required game files are loaded. You can now create the room.');
            }
        }

        function updateFileStatus(assetType, status, size = '') {
            const element = document.getElementById(assetType + 'Status');
            const fileItem = document.querySelector(`#fileList .file-item:nth-child(${CONFIG.REQUIRED_ASSETS.indexOf(assetType) + 1})`);
            
            element.textContent = status;
            
            if (status === 'loaded') {
                element.style.background = 'rgba(74, 222, 128, 0.2)';
                element.style.color = '#4ade80';
                fileItem.classList.add('loaded');
                
                if (size) {
                    const sizeElement = fileItem.querySelector('.file-size');
                    sizeElement.textContent = size;
                }
            } else if (status === 'Missing') {
                element.style.background = 'rgba(245, 158, 11, 0.2)';
                element.style.color = '#f59e0b';
                fileItem.classList.remove('loaded');
            }
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Room Creation with Assets
        function createRoomWithAssets() {
            // Generate room code
            gameState.roomCode = Math.floor(1000 + Math.random() * 9000).toString();
            gameState.isHost = true;
            
            // Create room data - L'hÃ´te commence avec isReady: false
            const roomData = {
                code: gameState.roomCode,
                hostId: gameState.playerId,
                hostName: gameState.playerName,
                players: [{
                    id: gameState.playerId,
                    name: gameState.playerName,
                    isReady: false, // L'hÃ´te doit aussi cliquer sur READY
                    isHost: true,
                    assetsLoaded: true
                }],
                assets: CONFIG.REQUIRED_ASSETS.reduce((acc, asset) => {
                    acc[asset] = gameState.assetFiles[asset] ? {
                        name: gameState.assetFiles[asset].name,
                        size: gameState.assetFiles[asset].size,
                        type: gameState.assetFiles[asset].type
                    } : null;
                    return acc;
                }, {}),
                gameStarted: false,
                lastUpdated: Date.now()
            };
            
            saveRoomData(roomData);
            
            // Update UI
            document.getElementById('roomCode').textContent = gameState.roomCode;
            showScreen('roomCreatedScreen');
            
            // Start checking for players
            checkForPlayers();
        }

        function checkForPlayers() {
            const interval = setInterval(() => {
                const roomData = getRoomData(gameState.roomCode);
                
                if (!roomData) {
                    clearInterval(interval);
                    return;
                }
                
                // Update connected players count
                document.getElementById('connectedPlayers').textContent = (roomData.players.length - 1);
                
                // If there are other players, show waiting room button
                if (roomData.players.length >= 2) {
                    document.getElementById('goToWaitingRoom').classList.remove('hidden');
                    clearInterval(interval);
                }
                
                // Check if any player needs assets
                roomData.players.forEach(player => {
                    if (player.id !== gameState.playerId && !player.assetsLoaded) {
                        // Send assets to this player
                        sendAssetsToPlayer(player.id);
                    }
                });
            }, 1000);
        }

        function goToWaitingRoom() {
            const roomData = getRoomData(gameState.roomCode);
            if (!roomData) return;
            
            gameState.players = roomData.players.reduce((acc, player) => {
                acc[player.id] = player;
                return acc;
            }, {});
            
            document.getElementById('roomCodeDisplay').textContent = `Room Code: ${gameState.roomCode}`;
            updatePlayersList();
            showScreen('waitingRoomScreen');
            
            // Mettre Ã  jour l'Ã©tat du bouton READY pour l'hÃ´te
            updateReadyButtonState();
            
            pollRoomUpdates();
        }

        function updateReadyButtonState() {
            const readyBtn = document.getElementById('readyBtn');
            if (gameState.isHost) {
                readyBtn.textContent = gameState.isReady ? 'NOT READY' : 'READY';
            } else {
                // Pour les joueurs qui rejoignent, ils doivent d'abord tÃ©lÃ©charger les assets
                const roomData = getRoomData(gameState.roomCode);
                if (roomData) {
                    const player = roomData.players.find(p => p.id === gameState.playerId);
                    if (player && player.assetsLoaded) {
                        readyBtn.textContent = gameState.isReady ? 'NOT READY' : 'READY';
                    } else {
                        readyBtn.textContent = 'WAITING FOR ASSETS';
                        readyBtn.disabled = true;
                    }
                }
            }
        }

        // Join Room
        function joinRoom() {
            const codeInput = document.getElementById('joinCodeInput');
            const code = codeInput.value.trim();
            
            if (code.length !== CONFIG.ROOM_CODE_LENGTH || !/^\d+$/.test(code)) {
                showNotification('Invalid Code', 'Please enter a valid 4-digit room code.');
                return;
            }
            
            gameState.roomCode = code;
            
            const roomData = getRoomData(code);
            
            if (!roomData) {
                showNotification('Room Not Found', 'No room found with that code.');
                return;
            }
            
            if (roomData.gameStarted) {
                showNotification('Game In Progress', 'This game has already started.');
                return;
            }
            
            // Add player to room
            const playerData = {
                id: gameState.playerId,
                name: gameState.playerName,
                isReady: false,
                isHost: false,
                assetsLoaded: false
            };
            
            roomData.players.push(playerData);
            roomData.lastUpdated = Date.now();
            saveRoomData(roomData);
            
            // Update game state
            gameState.isHost = false;
            gameState.players = roomData.players.reduce((acc, player) => {
                acc[player.id] = player;
                return acc;
            }, {});
            
            // Show waiting room
            document.getElementById('roomCodeDisplay').textContent = `Room Code: ${gameState.roomCode}`;
            updatePlayersList();
            showScreen('waitingRoomScreen');
            
            // Show download status et dÃ©sactiver le bouton READY
            document.getElementById('downloadStatus').classList.remove('hidden');
            document.getElementById('readyBtn').textContent = 'WAITING FOR ASSETS';
            document.getElementById('readyBtn').disabled = true;
            
            // Start downloading assets
            downloadAssetsFromHost(roomData.assets);
            pollRoomUpdates();
        }

        function downloadAssetsFromHost(assets) {
            showNotification('Downloading Assets', 'Downloading game assets from host...');
            
            // Simulate asset download
            let totalSize = 0;
            let downloadedSize = 0;
            
            CONFIG.REQUIRED_ASSETS.forEach(asset => {
                if (assets[asset]) {
                    totalSize += assets[asset].size;
                }
            });
            
            // Simulate download progress
            const simulateDownload = () => {
                if (downloadedSize < totalSize) {
                    downloadedSize += totalSize / 100; // 1% increments
                    const percent = Math.min(100, (downloadedSize / totalSize) * 100);
                    
                    document.getElementById('downloadBar').style.width = percent + '%';
                    document.getElementById('downloadProgress').textContent = 
                        `Downloading assets: ${Math.round(percent)}%`;
                    
                    // Simulate different file downloads
                    if (percent >= 25 && !receivedAssets.map) {
                        receivedAssets.map = true;
                        showNotification('Map Downloaded', 'Map asset downloaded successfully.');
                    }
                    if (percent >= 50 && !receivedAssets.player1) {
                        receivedAssets.player1 = true;
                        showNotification('Player Model Downloaded', 'Player 1 model downloaded.');
                    }
                    if (percent >= 75 && !receivedAssets.player2) {
                        receivedAssets.player2 = true;
                        showNotification('Player Model Downloaded', 'Player 2 model downloaded.');
                    }
                    if (percent >= 95 && !receivedAssets.enemy) {
                        receivedAssets.enemy = true;
                        showNotification('Enemy Model Downloaded', 'Enemy model downloaded.');
                    }
                    
                    if (percent >= 100) {
                        // All assets downloaded
                        document.getElementById('downloadStatus').classList.add('hidden');
                        
                        // Update room data
                        const roomData = getRoomData(gameState.roomCode);
                        if (roomData) {
                            const playerIndex = roomData.players.findIndex(p => p.id === gameState.playerId);
                            if (playerIndex !== -1) {
                                roomData.players[playerIndex].assetsLoaded = true;
                                saveRoomData(roomData);
                            }
                        }
                        
                        // Activer le bouton READY
                        document.getElementById('readyBtn').textContent = 'READY';
                        document.getElementById('readyBtn').disabled = false;
                        
                        showNotification('Assets Ready', 'All game assets downloaded. You can now ready up.');
                        return;
                    }
                    
                    setTimeout(simulateDownload, 100);
                }
            };
            
            simulateDownload();
        }

        function sendAssetsToPlayer(playerId) {
            // In a real implementation, this would send files via WebRTC data channels
            console.log(`Would send assets to player ${playerId}`);
        }

        // Room Management
        function saveRoomData(roomData) {
            const rooms = JSON.parse(localStorage.getItem(CONFIG.LOCAL_STORAGE_KEY) || '{}');
            rooms[roomData.code] = roomData;
            localStorage.setItem(CONFIG.LOCAL_STORAGE_KEY, JSON.stringify(rooms));
        }

        function getRoomData(code) {
            const rooms = JSON.parse(localStorage.getItem(CONFIG.LOCAL_STORAGE_KEY) || '{}');
            return rooms[code];
        }

        function deleteRoomData(code) {
            const rooms = JSON.parse(localStorage.getItem(CONFIG.LOCAL_STORAGE_KEY) || '{}');
            delete rooms[code];
            localStorage.setItem(CONFIG.LOCAL_STORAGE_KEY, JSON.stringify(rooms));
        }

        function pollRoomUpdates() {
            const interval = setInterval(() => {
                const roomData = getRoomData(gameState.roomCode);
                
                if (!roomData) {
                    clearInterval(interval);
                    showNotification('Room Closed', 'The host has closed the room.');
                    showMainMenu();
                    return;
                }
                
                // Update players
                gameState.players = roomData.players.reduce((acc, player) => {
                    acc[player.id] = player;
                    return acc;
                }, {});
                
                updatePlayersList();
                
                // Check if ALL players are ready and have assets
                const allPlayersReady = roomData.players.every(player => player.isReady && player.assetsLoaded);
                const atLeastTwoPlayers = roomData.players.length >= 2;
                
                // Mettre Ã  jour les contrÃ´les pour l'hÃ´te
                const hostControls = document.getElementById('hostControls');
                const readyBtn = document.getElementById('readyBtn');
                
                if (gameState.isHost) {
                    if (allPlayersReady && atLeastTwoPlayers) {
                        // Tous les joueurs sont prÃªts, montrer les contrÃ´les de lancement
                        hostControls.classList.remove('hidden');
                        readyBtn.classList.add('hidden');
                    } else {
                        // Certains joueurs ne sont pas prÃªts, montrer seulement le bouton READY
                        hostControls.classList.add('hidden');
                        readyBtn.classList.remove('hidden');
                        
                        // Mettre Ã  jour le texte du bouton
                        readyBtn.textContent = gameState.isReady ? 'NOT READY' : 'READY';
                    }
                } else {
                    // Pour les joueurs normaux, seulement montrer/masquer le bouton READY
                    const currentPlayer = roomData.players.find(p => p.id === gameState.playerId);
                    if (currentPlayer && currentPlayer.assetsLoaded) {
                        readyBtn.disabled = false;
                        readyBtn.textContent = gameState.isReady ? 'NOT READY' : 'READY';
                    }
                }
                
                // If game started, initialize game
                if (roomData.gameStarted && !gameState.gameStarted) {
                    clearInterval(interval);
                    gameState.gameStarted = true;
                    loadGameAssets();
                }
            }, 1000);
        }

        function updatePlayersList() {
            const playersList = document.getElementById('playersList');
            playersList.innerHTML = '';
            
            Object.values(gameState.players).forEach(player => {
                const playerCard = document.createElement('div');
                playerCard.className = 'player-card';
                if (player.isReady) playerCard.classList.add('ready');
                if (player.isHost) playerCard.classList.add('host');
                
                let status = player.isReady ? 'READY' : 'WAITING';
                let statusClass = player.isReady ? 'status-ready' : 'status-waiting';
                
                if (!player.assetsLoaded && !player.isHost) {
                    status = 'DOWNLOADING';
                    statusClass = 'status-downloading';
                }
                
                playerCard.innerHTML = `
                    <div class="player-avatar">${player.name.charAt(0).toUpperCase()}</div>
                    <div class="player-name">${player.name} ${player.isHost ? 'ðŸ‘‘' : ''}</div>
                    <div class="player-status ${statusClass}">
                        ${status}
                    </div>
                `;
                
                playersList.appendChild(playerCard);
            });
        }

        function toggleReady() {
            const roomData = getRoomData(gameState.roomCode);
            if (!roomData) return;
            
            const playerIndex = roomData.players.findIndex(p => p.id === gameState.playerId);
            if (playerIndex !== -1) {
                roomData.players[playerIndex].isReady = !roomData.players[playerIndex].isReady;
                gameState.isReady = roomData.players[playerIndex].isReady;
                roomData.lastUpdated = Date.now();
                
                saveRoomData(roomData);
                updatePlayersList();
                
                // Mettre Ã  jour le bouton
                const readyBtn = document.getElementById('readyBtn');
                readyBtn.textContent = gameState.isReady ? 'NOT READY' : 'READY';
                readyBtn.classList.toggle('btn-secondary', gameState.isReady);
                
                // Si l'hÃ´te devient prÃªt, vÃ©rifier si tout le monde est prÃªt
                if (gameState.isHost) {
                    const allPlayersReady = roomData.players.every(player => player.isReady && player.assetsLoaded);
                    const atLeastTwoPlayers = roomData.players.length >= 2;
                    
                    if (allPlayersReady && atLeastTwoPlayers) {
                        document.getElementById('hostControls').classList.remove('hidden');
                        readyBtn.classList.add('hidden');
                    }
                }
                
                showNotification(
                    gameState.isReady ? 'Ready!' : 'Not Ready',
                    gameState.isReady ? 'You are ready to play' : 'You are no longer ready'
                );
            }
        }

        function startGame() {
            const roomData = getRoomData(gameState.roomCode);
            if (!roomData || !gameState.isHost) return;
            
            roomData.gameStarted = true;
            roomData.lastUpdated = Date.now();
            saveRoomData(roomData);
            
            loadGameAssets();
        }

        function leaveWaitingRoom() {
            const roomData = getRoomData(gameState.roomCode);
            if (roomData) {
                roomData.players = roomData.players.filter(p => p.id !== gameState.playerId);
                
                if (roomData.players.length === 0 || (gameState.isHost && roomData.players.length > 0)) {
                    deleteRoomData(gameState.roomCode);
                } else {
                    saveRoomData(roomData);
                }
            }
            
            gameState.roomCode = null;
            gameState.isHost = false;
            gameState.isReady = false;
            gameState.players = {};
            gameState.assetFiles = {};
            
            showMainMenu();
        }

        // Game Initialization
        function loadGameAssets() {
            showLoadingScreen(true);
            updateLoadingProgress(0, 'Loading game assets...');
            
            // Simulate loading assets
            const assetsToLoad = CONFIG.REQUIRED_ASSETS;
            let loadedCount = 0;
            
            const loadNextAsset = () => {
                if (loadedCount < assetsToLoad.length) {
                    const asset = assetsToLoad[loadedCount];
                    const percent = (loadedCount / assetsToLoad.length) * 100;
                    
                    updateLoadingProgress(percent, `Loading ${asset}.glb...`);
                    
                    // Simulate loading time
                    setTimeout(() => {
                        loadedCount++;
                        showNotification('Asset Loaded', `${asset}.glb loaded successfully`);
                        loadNextAsset();
                    }, 500);
                } else {
                    updateLoadingProgress(100, 'All assets loaded!');
                    setTimeout(() => {
                        showLoadingScreen(false);
                        initializeGame();
                    }, 1000);
                }
            };
            
            loadNextAsset();
        }

        function initializeGame() {
            showScreen('gameScreen');
            
            // Update UI
            document.getElementById('uiPlayerName').textContent = gameState.playerName;
            updateTeamStatus();
            
            // Initialize Three.js
            initThreeJS();
            startGameLoop();
            startExtractionTimer();
            initializeMissions();
            
            // Start game simulation
            simulateGameEvents();
        }

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 20);
            
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('gameCanvas'), 
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Create game world
            createGameWorld();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }

        function createGameWorld() {
            // Ground
            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2a2a4a,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Buildings
            const buildings = [
                { x: -30, z: 20, w: 15, h: 10, d: 15, color: 0x3a3a6a, name: 'Server Room' },
                { x: 25, z: -25, w: 12, h: 8, d: 12, color: 0x5a3a3a, name: 'Intel Building' },
                { x: -20, z: -30, w: 10, h: 6, d: 10, color: 0x3a5a5a, name: 'Warehouse' },
                { x: 30, z: 20, w: 8, h: 5, d: 8, color: 0x5a5a3a, name: 'Guard Post' }
            ];
            
            buildings.forEach(building => {
                const geometry = new THREE.BoxGeometry(building.w, building.h, building.d);
                const material = new THREE.MeshStandardMaterial({ 
                    color: building.color,
                    roughness: 0.7
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(building.x, building.h / 2, building.z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
                
                // Add label
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                ctx.fillStyle = 'rgba(20, 20, 40, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.font = 'bold 20px Arial';
                ctx.fillStyle = '#e0e0ff';
                ctx.textAlign = 'center';
                ctx.fillText(building.name, canvas.width/2, canvas.height/2 + 8);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(building.x, building.h + 2, building.z);
                sprite.scale.set(10, 2.5, 1);
                scene.add(sprite);
            });
            
            // Create players
            createPlayers();
            
            // Create enemies
            createEnemies();
            
            // Create extraction zone
            createExtractionZone();
        }

        function createPlayers() {
            const playerGeometry = new THREE.CapsuleGeometry(0.5, 2, 4, 8);
            const playerColors = [0x4361ee, 0xf72585, 0x4ade80, 0xf59e0b];
            
            // Current player
            const playerMaterial = new THREE.MeshStandardMaterial({ 
                color: playerColors[0],
                emissive: playerColors[0],
                emissiveIntensity: 0.2
            });
            const playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
            playerMesh.position.set(0, 1, 0);
            playerMesh.castShadow = true;
            scene.add(playerMesh);
            
            playerObjects[gameState.playerId] = {
                mesh: playerMesh,
                name: gameState.playerName,
                health: 100,
                position: { x: 0, y: 1, z: 0 }
            };
            
            // Other players
            const otherPlayers = Object.values(gameState.players).filter(p => p.id !== gameState.playerId);
            otherPlayers.forEach((player, index) => {
                const material = new THREE.MeshStandardMaterial({ 
                    color: playerColors[(index + 1) % playerColors.length],
                    emissive: playerColors[(index + 1) % playerColors.length],
                    emissiveIntensity: 0.2
                });
                const mesh = new THREE.Mesh(playerGeometry, material);
                
                const positions = [
                    { x: 20, z: 0 },
                    { x: -20, z: 0 },
                    { x: 0, z: 20 }
                ];
                const pos = positions[index] || { x: 10, z: 10 };
                
                mesh.position.set(pos.x, 1, pos.z);
                mesh.castShadow = true;
                scene.add(mesh);
                
                playerObjects[player.id] = {
                    mesh: mesh,
                    name: player.name,
                    health: 100,
                    position: { x: pos.x, y: 1, z: pos.z }
                };
            });
            
            addPlayerLabels();
        }

        function addPlayerLabels() {
            Object.values(playerObjects).forEach(playerObj => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                
                ctx.fillStyle = 'rgba(20, 20, 40, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.font = 'bold 20px Arial';
                ctx.fillStyle = '#e0e0ff';
                ctx.textAlign = 'center';
                ctx.fillText(playerObj.name, canvas.width/2, canvas.height/2);
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(material);
                sprite.position.set(0, 3, 0);
                sprite.scale.set(5, 1.25, 1);
                
                playerObj.mesh.add(sprite);
                playerObj.label = sprite;
            });
        }

        function createEnemies() {
            const enemyGeometry = new THREE.ConeGeometry(0.6, 2, 8);
            const enemyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xaa3333,
                emissive: 0xaa3333,
                emissiveIntensity: 0.1
            });
            
            for (let i = 0; i < 12; i++) {
                const enemyMesh = new THREE.Mesh(enemyGeometry, enemyMaterial);
                
                let x, z;
                if (i < 4) {
                    x = -30 + (Math.random() - 0.5) * 10;
                    z = 20 + (Math.random() - 0.5) * 10;
                } else if (i < 8) {
                    x = 25 + (Math.random() - 0.5) * 10;
                    z = -25 + (Math.random() - 0.5) * 10;
                } else {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 15 + Math.random() * 20;
                    x = Math.cos(angle) * radius;
                    z = Math.sin(angle) * radius;
                }
                
                enemyMesh.position.set(x, 1, z);
                enemyMesh.castShadow = true;
                scene.add(enemyMesh);
                
                enemyObjects.push({
                    mesh: enemyMesh,
                    health: 100,
                    position: { x, y: 1, z },
                    alive: true
                });
            }
        }

        function createExtractionZone() {
            const extractionGeometry = new THREE.CylinderGeometry(8, 8, 0.2, 32);
            const extractionMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4ade80,
                emissive: 0x4ade80,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.5
            });
            
            extractionZone = new THREE.Mesh(extractionGeometry, extractionMaterial);
            extractionZone.position.set(0, 0.1, 0);
            scene.add(extractionZone);
            
            extractionZone.userData.pulseDirection = 1;
            extractionZone.userData.originalOpacity = 0.5;
        }

        function startExtractionTimer() {
            const timerElement = document.getElementById('extractionTimer');
            
            const timerInterval = setInterval(() => {
                gameState.extractionTimer--;
                
                const minutes = Math.floor(gameState.extractionTimer / 60);
                const seconds = gameState.extractionTimer % 60;
                
                timerElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                if (gameState.extractionTimer <= 30) {
                    timerElement.classList.add('pulse');
                }
                
                if (gameState.extractionTimer <= 0) {
                    clearInterval(timerInterval);
                    gameState.extractionAvailable = true;
                    timerElement.textContent = 'EXTRACTION READY';
                    showNotification('Extraction Available', 'Meet your partner at the extraction zone!');
                    document.getElementById('mission4').classList.remove('hidden');
                }
            }, 1000);
        }

        function initializeMissions() {
            window.checkEnemyKill = function() {
                gameState.missions.enemiesKilled++;
                document.getElementById('uiKills').textContent = gameState.missions.enemiesKilled;
                
                const missionElement = document.getElementById('mission1');
                missionElement.querySelector('span').textContent = 
                    `Eliminate 10 enemies (${gameState.missions.enemiesKilled}/10)`;
                
                if (gameState.missions.enemiesKilled >= 10) {
                    missionElement.classList.add('completed');
                    showNotification('Mission Complete', 'Enemy elimination objective completed!');
                }
            };
            
            window.secureServerRoom = function() {
                if (!gameState.missions.serverSecured) {
                    gameState.missions.serverSecured = true;
                    document.getElementById('mission2').classList.add('completed');
                    updateObjectivesCount();
                    showNotification('Server Secured', 'Server room has been secured!');
                }
            };
            
            window.downloadIntel = function() {
                if (!gameState.missions.intelDownloaded) {
                    gameState.missions.intelDownloaded = true;
                    document.getElementById('mission3').classList.add('completed');
                    updateObjectivesCount();
                    showNotification('Intel Downloaded', 'Critical intelligence data acquired!');
                }
            };
            
            function updateObjectivesCount() {
                const count = (gameState.missions.serverSecured ? 1 : 0) + 
                             (gameState.missions.intelDownloaded ? 1 : 0);
                document.getElementById('uiObjectives').textContent = count;
            }
            
            // Demo controls
            document.addEventListener('keydown', (e) => {
                if (e.key === '1') window.checkEnemyKill();
                if (e.key === '2') window.secureServerRoom();
                if (e.key === '3') window.downloadIntel();
                if (e.key === '4' && gameState.extractionAvailable) {
                    document.getElementById('mission4').classList.add('completed');
                    showNotification('Extraction Complete', 'Mission accomplished! Well done, team.');
                }
            });
            
            showNotification('Controls', 'Press 1-4 to simulate mission progress');
        }

        function updateTeamStatus() {
            const teamStatus = document.getElementById('teamStatus');
            teamStatus.innerHTML = '';
            
            Object.values(playerObjects).forEach(player => {
                const div = document.createElement('div');
                div.className = 'team-member';
                div.innerHTML = `
                    <strong>${player.name}</strong><br>
                    Health: ${player.health}<br>
                    Status: ${player.health > 0 ? 'ACTIVE' : 'DOWN'}
                `;
                teamStatus.appendChild(div);
            });
        }

        function startGameLoop() {
            function animate() {
                requestAnimationFrame(animate);
                
                gameState.gameTime += 0.016;
                
                // Pulse extraction zone
                if (extractionZone) {
                    extractionZone.material.opacity += 0.02 * extractionZone.userData.pulseDirection;
                    if (extractionZone.material.opacity >= 0.7 || extractionZone.material.opacity <= 0.3) {
                        extractionZone.userData.pulseDirection *= -1;
                    }
                }
                
                // Rotate enemies
                enemyObjects.forEach(enemy => {
                    if (enemy.alive) {
                        enemy.mesh.rotation.y += 0.01;
                    }
                });
                
                // Rotate players
                Object.values(playerObjects).forEach(player => {
                    player.mesh.rotation.y += 0.005;
                });
                
                renderer.render(scene, camera);
            }
            
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function simulateGameEvents() {
            // Simulate enemy kills
            let killCount = 0;
            const killInterval = setInterval(() => {
                if (killCount < 10 && gameState.gameStarted) {
                    window.checkEnemyKill();
                    killCount++;
                    
                    // Random damage to players
                    Object.values(playerObjects).forEach(player => {
                        if (Math.random() > 0.7 && player.health > 0) {
                            player.health -= Math.floor(Math.random() * 20) + 5;
                            if (player.health < 0) player.health = 0;
                            document.getElementById('uiHealth').textContent = playerObjects[gameState.playerId].health;
                            updateTeamStatus();
                        }
                    });
                } else {
                    clearInterval(killInterval);
                }
            }, 3000);
            
            // Simulate mission completions
            setTimeout(() => {
                if (gameState.gameStarted) window.secureServerRoom();
            }, 8000);
            
            setTimeout(() => {
                if (gameState.gameStarted) window.downloadIntel();
            }, 15000);
        }

        function showNotification(title, message, duration = 5000) {
            const notificationArea = document.getElementById('notificationArea');
            
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.innerHTML = `
                <div class="notification-title">${title}</div>
                <div class="notification-message">${message}</div>
            `;
            
            notificationArea.appendChild(notification);
            
            setTimeout(() => notification.classList.add('show'), 10);
            
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 500);
            }, duration);
        }
    </script>
</body>
</html>
