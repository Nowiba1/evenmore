<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mission Extraction - Local Network Multiplayer</title>
    <style>
        /* [Same CSS as before - kept for completeness] */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0c0c1d 0%, #1a1a2e 100%);
            color: #e0e0ff;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        /* Screens */
        .screen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 20px;
            transition: opacity 0.5s;
        }
        
        .screen.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        /* Main Menu */
        .title {
            font-size: 3.5rem;
            font-weight: 800;
            text-align: center;
            margin-bottom: 20px;
            background: linear-gradient(90deg, #4cc9f0, #4361ee);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 20px rgba(76, 201, 240, 0.3);
            letter-spacing: 2px;
        }
        
        .subtitle {
            font-size: 1.2rem;
            margin-bottom: 40px;
            text-align: center;
            color: #a0a0ff;
            max-width: 600px;
        }
        
        /* Room Controls */
        .room-controls {
            background: rgba(20, 20, 40, 0.8);
            border-radius: 15px;
            padding: 30px;
            width: 100%;
            max-width: 500px;
            border: 1px solid rgba(76, 201, 240, 0.3);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            margin-bottom: 30px;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #4cc9f0;
        }
        
        input {
            width: 100%;
            padding: 12px 15px;
            background: rgba(10, 10, 25, 0.8);
            border: 1px solid #4361ee;
            border-radius: 8px;
            color: white;
            font-size: 1.1rem;
            letter-spacing: 2px;
            text-align: center;
        }
        
        input:focus {
            outline: none;
            border-color: #4cc9f0;
            box-shadow: 0 0 10px rgba(76, 201, 240, 0.5);
        }
        
        .btn {
            display: block;
            width: 100%;
            padding: 15px;
            margin-top: 15px;
            background: linear-gradient(90deg, #4361ee, #3a0ca3);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 7px 15px rgba(67, 97, 238, 0.4);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn-secondary {
            background: linear-gradient(90deg, #f72585, #b5179e);
        }
        
        .btn-success {
            background: linear-gradient(90deg, #4ade80, #16a34a);
        }
        
        /* Asset Configuration */
        .asset-config {
            background: rgba(20, 20, 40, 0.8);
            border-radius: 15px;
            padding: 30px;
            width: 100%;
            max-width: 600px;
            border: 1px solid rgba(76, 201, 240, 0.3);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            margin-bottom: 30px;
        }
        
        .asset-note {
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            color: #f59e0b;
        }
        
        .asset-url-input {
            font-size: 0.9rem;
            padding: 10px;
            background: rgba(10, 10, 25, 0.8);
            border: 1px solid #4361ee;
            border-radius: 8px;
            color: #a0a0ff;
            margin-top: 8px;
            width: 100%;
        }
        
        /* Waiting Room */
        .players-list {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            margin: 30px 0;
        }
        
        .player-card {
            background: rgba(30, 30, 60, 0.8);
            border-radius: 10px;
            padding: 20px;
            width: 200px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s;
        }
        
        .player-card.ready {
            border-color: #4ade80;
            box-shadow: 0 0 15px rgba(74, 222, 128, 0.3);
        }
        
        .player-card.host {
            border-color: #4cc9f0;
        }
        
        .player-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            margin: 0 auto 15px;
            background: linear-gradient(135deg, #4361ee, #3a0ca3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
        }
        
        .player-name {
            font-weight: 600;
            margin-bottom: 10px;
            color: #e0e0ff;
        }
        
        .player-status {
            font-size: 0.9rem;
            padding: 5px 10px;
            border-radius: 20px;
            display: inline-block;
        }
        
        .status-ready {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
        }
        
        .status-waiting {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
        }
        
        /* Game Screen */
        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .game-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
        }
        
        .ui-panel {
            background: rgba(20, 20, 40, 0.8);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(76, 201, 240, 0.3);
            min-width: 200px;
            backdrop-filter: blur(5px);
            pointer-events: auto;
        }
        
        .mission-list {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(20, 20, 40, 0.8);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(76, 201, 240, 0.3);
            width: 300px;
            backdrop-filter: blur(5px);
        }
        
        .mission-item {
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
        }
        
        .mission-item.completed {
            color: #4ade80;
        }
        
        .mission-checkbox {
            margin-right: 10px;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 2px solid #4361ee;
            display: inline-block;
        }
        
        .mission-item.completed .mission-checkbox {
            background: #4ade80;
            border-color: #4ade80;
        }
        
        .extraction-timer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 20, 40, 0.8);
            border-radius: 10px;
            padding: 15px 25px;
            border: 1px solid rgba(76, 201, 240, 0.3);
            font-size: 1.3rem;
            font-weight: 600;
            color: #4cc9f0;
            text-align: center;
            backdrop-filter: blur(5px);
        }
        
        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 25, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .loading-progress {
            width: 80%;
            max-width: 400px;
            height: 20px;
            background: rgba(20, 20, 40, 0.8);
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
            border: 1px solid #4361ee;
        }
        
        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #4361ee, #4cc9f0);
            width: 0%;
            transition: width 0.3s;
            border-radius: 10px;
        }
        
        .loading-file {
            margin-top: 10px;
            color: #a0a0ff;
            font-size: 0.9rem;
        }
        
        /* Notifications */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 40, 0.95);
            border-radius: 10px;
            padding: 15px;
            border-left: 5px solid #4361ee;
            max-width: 350px;
            transform: translateX(400px);
            transition: transform 0.5s;
            z-index: 1000;
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        .notification-title {
            font-weight: 600;
            margin-bottom: 5px;
            color: #4cc9f0;
        }
        
        /* Code Display */
        .code-display {
            font-size: 3rem;
            font-weight: 800;
            letter-spacing: 10px;
            text-align: center;
            background: rgba(10, 10, 25, 0.8);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            color: #4ade80;
            border: 2px solid #4361ee;
        }
        
        /* Instructions */
        .instructions {
            background: rgba(20, 20, 40, 0.6);
            border-radius: 10px;
            padding: 20px;
            margin-top: 30px;
            border: 1px solid rgba(76, 201, 240, 0.2);
        }
        
        .instructions h3 {
            color: #4cc9f0;
            margin-bottom: 10px;
        }
        
        .instructions ul {
            padding-left: 20px;
        }
        
        .instructions li {
            margin-bottom: 8px;
            line-height: 1.5;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .title {
                font-size: 2.5rem;
            }
            
            .room-controls, .asset-config {
                padding: 20px;
            }
            
            .ui-panel, .mission-list {
                transform: scale(0.9);
                transform-origin: top left;
            }
        }
        
        /* Animations */
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
        
        /* Loading */
        .loader {
            border: 5px solid rgba(67, 97, 238, 0.3);
            border-top: 5px solid #4361ee;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- Asset Configuration Screen -->
    <div id="assetConfigScreen" class="screen">
        <h1 class="title">ASSET CONFIGURATION</h1>
        <p class="subtitle">Configure asset URLs for the game</p>
        
        <div class="asset-config">
            <div class="asset-note">
                <strong>Important:</strong> Due to GitHub's 25MB file limit, large assets (like your 80MB map) must be hosted separately.
                <br><br>
                You can use free services like Google Drive, Dropbox, or any web hosting that supports CORS.
                Enter the direct download URLs for each asset below.
            </div>
            
            <div class="input-group">
                <label for="mapUrl">Map File URL (.glb or .gltf)</label>
                <input type="text" id="mapUrl" placeholder="https://example.com/path/to/map.glb">
                <small class="asset-url-input">Default: https://raw.githubusercontent.com/username/repo/main/map.glb (if under 25MB)</small>
            </div>
            
            <div class="input-group">
                <label for="player1Url">Player 1 Model URL</label>
                <input type="text" id="player1Url" placeholder="https://example.com/path/to/player1.glb">
            </div>
            
            <div class="input-group">
                <label for="player2Url">Player 2 Model URL</label>
                <input type="text" id="player2Url" placeholder="https://example.com/path/to/player2.glb">
            </div>
            
            <div class="input-group">
                <label for="enemyUrl">Enemy Model URL</label>
                <input type="text" id="enemyUrl" placeholder="https://example.com/path/to/enemy.glb">
            </div>
            
            <div class="input-group">
                <label for="useDefaultAssets">
                    <input type="checkbox" id="useDefaultAssets" checked>
                    Use default placeholder models (if URLs are empty or fail to load)
                </label>
            </div>
            
            <button id="saveAssetConfig" class="btn btn-success">SAVE & CONTINUE</button>
            <button id="skipAssetConfig" class="btn btn-secondary">SKIP (Use Placeholders)</button>
            
            <div class="instructions">
                <h3>How to get asset URLs:</h3>
                <ul>
                    <li><strong>Google Drive:</strong> Share file → Get shareable link → Replace "/view" with "/uc?export=download"</li>
                    <li><strong>Dropbox:</strong> Share → Create link → Change "dl=0" to "dl=1" at the end</li>
                    <li><strong>GitHub:</strong> Upload to repo → Right click file → "Copy link address" (must be under 25MB)</li>
                    <li><strong>Self-hosted:</strong> Run a local server and use your local IP address</li>
                </ul>
            </div>
        </div>
    </div>
    
    <!-- Main Menu Screen -->
    <div id="mainMenu" class="screen">
        <h1 class="title">MISSION EXTRACTION</h1>
        <p class="subtitle">Local Network Co-op Tactical Operations</p>
        
        <div class="room-controls">
            <div class="input-group">
                <label for="playerName">Your Call Sign</label>
                <input type="text" id="playerName" placeholder="Enter your name" value="Operator" maxlength="12">
            </div>
            
            <button id="createRoomBtn" class="btn">CREATE ROOM</button>
            <button id="joinRoomBtn" class="btn btn-secondary">JOIN ROOM</button>
            <button id="configureAssetsBtn" class="btn">CONFIGURE ASSETS</button>
        </div>
        
        <div class="instructions">
            <h3>How to Play:</h3>
            <ul>
                <li>One player creates a room and shares the 4-digit code</li>
                <li>Other players join using the code on the same local network</li>
                <li>Complete missions: eliminate enemies, secure objectives</li>
                <li>Meet your partner at the extraction point after 2 minutes</li>
                <li>Both players must be at extraction to win</li>
            </ul>
        </div>
    </div>
    
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen hidden">
        <h1 class="title">LOADING ASSETS</h1>
        <p class="subtitle">Please wait while game assets are loading...</p>
        
        <div class="loading-progress">
            <div class="loading-bar" id="loadingBar"></div>
        </div>
        
        <div class="loading-file" id="loadingFile">Initializing...</div>
        
        <div class="loader"></div>
        
        <p id="loadingStatus">Preparing game environment...</p>
        
        <button id="cancelLoading" class="btn btn-secondary hidden" style="margin-top: 30px;">CANCEL & USE PLACEHOLDERS</button>
    </div>
    
    <!-- [Rest of the screens are the same as before but would go here] -->
    <!-- Room Creation Screen -->
    <div id="createRoomScreen" class="screen">
        <h1 class="title">ROOM CREATED</h1>
        <p class="subtitle">Share this code with other players on your local network</p>
        
        <div class="code-display" id="roomCode">----</div>
        
        <div class="room-controls">
            <p>Waiting for players to join...</p>
            <div class="loader"></div>
            <button id="startWaitingRoomBtn" class="btn btn-success hidden">GO TO WAITING ROOM</button>
        </div>
    </div>
    
    <!-- Join Room Screen -->
    <div id="joinRoomScreen" class="screen">
        <h1 class="title">JOIN ROOM</h1>
        <p class="subtitle">Enter the 4-digit room code provided by the host</p>
        
        <div class="room-controls">
            <div class="input-group">
                <label for="joinCodeInput">Room Code</label>
                <input type="text" id="joinCodeInput" placeholder="Enter 4-digit code" maxlength="4" pattern="\d{4}">
            </div>
            
            <button id="joinWithCodeBtn" class="btn">JOIN</button>
            <button id="backToMainBtn" class="btn btn-secondary">BACK</button>
        </div>
    </div>
    
    <!-- Waiting Room Screen -->
    <div id="waitingRoomScreen" class="screen">
        <h1 class="title">WAITING ROOM</h1>
        <p class="subtitle" id="roomCodeDisplay">Room Code: ----</p>
        
        <div class="players-list" id="playersList">
            <!-- Player cards will be inserted here -->
        </div>
        
        <div class="room-controls">
            <div id="playerStatus">
                <button id="readyBtn" class="btn">READY</button>
                <p id="hostMessage" class="hidden">All players ready. You can start the mission.</p>
                <button id="startMissionBtn" class="btn btn-success hidden">LAUNCH MISSION</button>
            </div>
            <button id="leaveWaitingRoomBtn" class="btn btn-secondary">LEAVE ROOM</button>
        </div>
    </div>
    
    <!-- Game Screen -->
    <div id="gameScreen" class="screen">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Game UI Overlay -->
        <div class="game-ui">
            <div class="ui-panel">
                <h3>OPERATOR STATUS</h3>
                <p>Player: <span id="uiPlayerName">---</span></p>
                <p>Health: <span id="uiHealth">100</span></p>
                <p>Enemies Eliminated: <span id="uiKills">0</span>/10</p>
                <p>Objectives: <span id="uiObjectives">0</span>/3</p>
            </div>
            
            <div class="ui-panel">
                <h3>TEAM STATUS</h3>
                <div id="teamStatus">
                    <!-- Team member status will be inserted here -->
                </div>
            </div>
        </div>
        
        <div class="extraction-timer">
            Extraction Available In: <span id="extractionTimer">02:00</span>
        </div>
        
        <div class="mission-list">
            <h3>ACTIVE MISSIONS</h3>
            <div class="mission-item" id="mission1">
                <div class="mission-checkbox"></div>
                <span>Eliminate 10 enemies (0/10)</span>
            </div>
            <div class="mission-item" id="mission2">
                <div class="mission-checkbox"></div>
                <span>Secure server room</span>
            </div>
            <div class="mission-item" id="mission3">
                <div class="mission-checkbox"></div>
                <span>Download intel data</span>
            </div>
            <div class="mission-item" id="mission4">
                <div class="mission-checkbox"></div>
                <span>Extract with partner</span>
            </div>
        </div>
    </div>
    
    <!-- Notification System -->
    <div id="notificationArea"></div>

    <!-- Three.js and Game Logic -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    
    <script>
        // Game State and Configuration
        const CONFIG = {
            ROOM_CODE_LENGTH: 4,
            MAX_PLAYERS: 4,
            EXTRACTION_TIME_MINUTES: 2,
            LOCAL_STORAGE_KEY: 'mission_extraction_rooms',
            ASSET_CONFIG_KEY: 'mission_extraction_assets',
            
            // Default fallback URLs (can be replaced by user configuration)
            DEFAULT_ASSETS: {
                map: 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/models/gltf/DamagedHelmet/glTF/DamagedHelmet.gltf', // Small example model
                player1: '', // Empty = use placeholder
                player2: '', // Empty = use placeholder
                enemy: ''    // Empty = use placeholder
            }
        };

        // Game State
        let gameState = {
            currentScreen: 'mainMenu',
            playerId: null,
            playerName: 'Operator',
            roomCode: null,
            isHost: false,
            isReady: false,
            peerConnections: {},
            dataChannels: {},
            players: {},
            gameStarted: false,
            missions: {
                enemiesKilled: 0,
                serverSecured: false,
                intelDownloaded: false,
                extractionReady: false
            },
            extractionTimer: CONFIG.EXTRACTION_TIME_MINUTES * 60, // in seconds
            extractionAvailable: false,
            gameTime: 0,
            assetUrls: {
                map: '',
                player1: '',
                player2: '',
                enemy: ''
            },
            assetsLoaded: false,
            usePlaceholders: true
        };

        // Three.js variables
        let scene, camera, renderer, controls;
        let mapModel, player1Model, player2Model, enemyModel;
        let playerObjects = {};
        let enemyObjects = [];
        let extractionZone = null;

        // DOM Elements
        const screens = {
            assetConfig: document.getElementById('assetConfigScreen'),
            mainMenu: document.getElementById('mainMenu'),
            createRoomScreen: document.getElementById('createRoomScreen'),
            joinRoomScreen: document.getElementById('joinRoomScreen'),
            waitingRoomScreen: document.getElementById('waitingRoomScreen'),
            gameScreen: document.getElementById('gameScreen')
        };

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            initEventListeners();
            generatePlayerId();
            loadPlayerName();
            loadAssetConfig();
            
            // Show asset config on first run
            if (!localStorage.getItem(CONFIG.ASSET_CONFIG_KEY)) {
                showScreen('assetConfig');
            } else {
                showScreen('mainMenu');
            }
        });

        function initEventListeners() {
            // Asset Configuration
            document.getElementById('saveAssetConfig').addEventListener('click', saveAssetConfig);
            document.getElementById('skipAssetConfig').addEventListener('click', skipAssetConfig);
            document.getElementById('configureAssetsBtn').addEventListener('click', () => showScreen('assetConfig'));
            document.getElementById('cancelLoading').addEventListener('click', cancelAssetLoading);
            
            // Main Menu
            document.getElementById('createRoomBtn').addEventListener('click', createRoom);
            document.getElementById('joinRoomBtn').addEventListener('click', showJoinScreen);
            
            // Join Room Screen
            document.getElementById('joinWithCodeBtn').addEventListener('click', joinRoom);
            document.getElementById('backToMainBtn').addEventListener('click', showMainMenu);
            document.getElementById('joinCodeInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') joinRoom();
            });
            
            // Waiting Room
            document.getElementById('readyBtn').addEventListener('click', toggleReady);
            document.getElementById('startMissionBtn').addEventListener('click', startGame);
            document.getElementById('leaveWaitingRoomBtn').addEventListener('click', leaveWaitingRoom);
            
            // Player name input
            document.getElementById('playerName').addEventListener('input', (e) => {
                gameState.playerName = e.target.value || 'Operator';
                localStorage.setItem('playerName', gameState.playerName);
            });
        }

        function generatePlayerId() {
            gameState.playerId = 'player_' + Math.random().toString(36).substr(2, 9);
        }

        function loadPlayerName() {
            const savedName = localStorage.getItem('playerName');
            if (savedName) {
                gameState.playerName = savedName;
                document.getElementById('playerName').value = savedName;
            }
        }

        function loadAssetConfig() {
            const savedConfig = localStorage.getItem(CONFIG.ASSET_CONFIG_KEY);
            if (savedConfig) {
                const config = JSON.parse(savedConfig);
                gameState.assetUrls = config.assetUrls || {};
                gameState.usePlaceholders = config.usePlaceholders !== false;
                
                // Update UI fields
                document.getElementById('mapUrl').value = gameState.assetUrls.map || '';
                document.getElementById('player1Url').value = gameState.assetUrls.player1 || '';
                document.getElementById('player2Url').value = gameState.assetUrls.player2 || '';
                document.getElementById('enemyUrl').value = gameState.assetUrls.enemy || '';
                document.getElementById('useDefaultAssets').checked = gameState.usePlaceholders;
            }
        }

        function saveAssetConfig() {
            gameState.assetUrls = {
                map: document.getElementById('mapUrl').value.trim(),
                player1: document.getElementById('player1Url').value.trim(),
                player2: document.getElementById('player2Url').value.trim(),
                enemy: document.getElementById('enemyUrl').value.trim()
            };
            
            gameState.usePlaceholders = document.getElementById('useDefaultAssets').checked;
            
            // Save to localStorage
            const config = {
                assetUrls: gameState.assetUrls,
                usePlaceholders: gameState.usePlaceholders,
                savedAt: Date.now()
            };
            
            localStorage.setItem(CONFIG.ASSET_CONFIG_KEY, JSON.stringify(config));
            
            showNotification('Configuration Saved', 'Asset URLs have been saved successfully.');
            showScreen('mainMenu');
        }

        function skipAssetConfig() {
            gameState.usePlaceholders = true;
            showScreen('mainMenu');
        }

        function showScreen(screenName) {
            Object.values(screens).forEach(screen => {
                screen.classList.remove('active');
            });
            
            screens[screenName].classList.add('active');
            gameState.currentScreen = screenName;
        }

        function showMainMenu() {
            showScreen('mainMenu');
        }

        function showLoadingScreen(show = true) {
            const loadingScreen = document.getElementById('loadingScreen');
            if (show) {
                loadingScreen.classList.remove('hidden');
            } else {
                loadingScreen.classList.add('hidden');
            }
        }

        function updateLoadingProgress(percent, filename) {
            document.getElementById('loadingBar').style.width = percent + '%';
            document.getElementById('loadingFile').textContent = filename ? `Loading: ${filename}` : 'Loading assets...';
            document.getElementById('loadingStatus').textContent = `${Math.round(percent)}% complete`;
            
            if (percent > 50 && percent < 100) {
                document.getElementById('cancelLoading').classList.remove('hidden');
            }
        }

        function cancelAssetLoading() {
            gameState.assetsLoaded = false;
            showLoadingScreen(false);
            showNotification('Asset Loading Cancelled', 'Using placeholder models instead.');
            initializeGameWithPlaceholders();
        }

        // Asset Loading System
        async function loadGameAssets() {
            showLoadingScreen(true);
            updateLoadingProgress(0, 'Initializing asset loader...');
            
            const assetsToLoad = [];
            const loadedAssets = {};
            
            // Prepare asset URLs
            const assetConfig = {
                map: gameState.assetUrls.map || CONFIG.DEFAULT_ASSETS.map,
                player1: gameState.assetUrls.player1 || '',
                player2: gameState.assetUrls.player2 || '',
                enemy: gameState.assetUrls.enemy || ''
            };
            
            // Check which assets to load
            if (assetConfig.map) {
                assetsToLoad.push({type: 'map', url: assetConfig.map});
            }
            if (assetConfig.player1) {
                assetsToLoad.push({type: 'player1', url: assetConfig.player1});
            }
            if (assetConfig.player2) {
                assetsToLoad.push({type: 'player2', url: assetConfig.player2});
            }
            if (assetConfig.enemy) {
                assetsToLoad.push({type: 'enemy', url: assetConfig.enemy});
            }
            
            if (assetsToLoad.length === 0) {
                // No assets to load, use placeholders
                updateLoadingProgress(100, 'No assets configured');
                setTimeout(() => {
                    showLoadingScreen(false);
                    initializeGameWithPlaceholders();
                }, 1000);
                return;
            }
            
            // Load assets one by one with progress tracking
            for (let i = 0; i < assetsToLoad.length; i++) {
                const asset = assetsToLoad[i];
                const progress = (i / assetsToLoad.length) * 100;
                updateLoadingProgress(progress, `${asset.type}.glb`);
                
                try {
                    loadedAssets[asset.type] = await loadGLTFModel(asset.url);
                    showNotification('Asset Loaded', `${asset.type} loaded successfully`);
                } catch (error) {
                    console.error(`Failed to load ${asset.type}:`, error);
                    showNotification('Load Error', `Failed to load ${asset.type}. Using placeholder instead.`);
                    loadedAssets[asset.type] = null;
                }
            }
            
            updateLoadingProgress(100, 'Assets loaded');
            
            // Store loaded models
            if (loadedAssets.map) mapModel = loadedAssets.map;
            if (loadedAssets.player1) player1Model = loadedAssets.player1;
            if (loadedAssets.player2) player2Model = loadedAssets.player2;
            if (loadedAssets.enemy) enemyModel = loadedAssets.enemy;
            
            gameState.assetsLoaded = true;
            
            setTimeout(() => {
                showLoadingScreen(false);
                initializeGame();
            }, 1000);
        }

        function loadGLTFModel(url) {
            return new Promise((resolve, reject) => {
                if (!url || url.trim() === '') {
                    reject(new Error('Empty URL'));
                    return;
                }
                
                const loader = new THREE.GLTFLoader();
                
                // Set up progress tracking for individual file
                loader.manager.onProgress = function(item, loaded, total) {
                    const percent = (loaded / total) * 100;
                    updateLoadingProgress(percent, item.split('/').pop());
                };
                
                loader.load(
                    url,
                    (gltf) => {
                        resolve(gltf.scene);
                    },
                    (progress) => {
                        // Progress callback (optional)
                    },
                    (error) => {
                        reject(error);
                    }
                );
            });
        }

        // [Rest of the game functions remain the same as previous implementation]
        // Including: createRoom, joinRoom, showJoinScreen, checkForPlayers, etc.
        // ... [Previous networking and game logic code would go here]

        // For brevity, I'll include the key changed parts and note where previous code should be inserted

        function startGame() {
            const roomData = getRoomData(gameState.roomCode);
            if (!roomData || !gameState.isHost) return;
            
            roomData.gameStarted = true;
            roomData.lastUpdated = Date.now();
            saveRoomData(roomData);
            
            // Load assets before initializing game
            loadGameAssets();
        }

        function initializeGameWithPlaceholders() {
            // Initialize game with placeholder geometry instead of loaded models
            showScreen('gameScreen');
            
            // Update UI elements
            document.getElementById('uiPlayerName').textContent = gameState.playerName;
            updateTeamStatus();
            
            // Initialize Three.js with placeholders
            initThreeJSWithPlaceholders();
            startGameLoop();
            startExtractionTimer();
            initializeMissions();
        }

        function initThreeJSWithPlaceholders() {
            // Create scene with placeholder geometry
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 20);
            
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Create placeholder map
            createPlaceholderMap();
            
            // Create placeholder players and enemies
            createPlaceholderPlayers();
            createPlaceholderEnemies();
            createExtractionZone();
            
            window.addEventListener('resize', onWindowResize);
        }

        function createPlaceholderMap() {
            // Create a simple procedural map since we can't load the 80MB file
            const groundGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);
            
            // Create terrain with height variations
            const vertices = groundGeometry.attributes.position;
            for (let i = 0; i < vertices.count; i++) {
                const x = vertices.getX(i);
                const y = vertices.getY(i);
                const z = vertices.getZ(i);
                
                // Add some height variation
                const height = Math.sin(x * 0.1) * Math.cos(z * 0.1) * 5;
                vertices.setZ(i, height);
            }
            
            groundGeometry.computeVertexNormals();
            
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2a4a2a,
                roughness: 0.8,
                metalness: 0.2
            });
            
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Add buildings and structures
            addProceduralBuildings();
            addMissionObjectives();
        }

        function addProceduralBuildings() {
            const buildingTypes = [
                { geometry: new THREE.BoxGeometry(8, 12, 8), color: 0x3a3a6a },
                { geometry: new THREE.CylinderGeometry(4, 4, 10, 6), color: 0x5a3a3a },
                { geometry: new THREE.ConeGeometry(5, 8, 8), color: 0x3a5a3a }
            ];
            
            // Create random buildings
            for (let i = 0; i < 15; i++) {
                const type = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
                const building = new THREE.Mesh(type.geometry, new THREE.MeshStandardMaterial({ 
                    color: type.color,
                    roughness: 0.7
                }));
                
                const angle = (i / 15) * Math.PI * 2;
                const radius = 30 + Math.random() * 40;
                building.position.set(
                    Math.cos(angle) * radius,
                    type.geometry.parameters.height / 2,
                    Math.sin(angle) * radius
                );
                
                building.castShadow = true;
                scene.add(building);
                
                // Add windows or details
                if (Math.random() > 0.5) {
                    const windowGeometry = new THREE.BoxGeometry(1, 2, 0.2);
                    const windowMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xffffaa,
                        emissive: 0xffff00,
                        emissiveIntensity: 0.3
                    });
                    
                    for (let w = 0; w < 4; w++) {
                        const window = new THREE.Mesh(windowGeometry, windowMaterial);
                        window.position.set(
                            building.position.x + (Math.random() - 0.5) * 4,
                            building.position.y - 2 + w * 3,
                            building.position.z + 4.1
                        );
                        scene.add(window);
                    }
                }
            }
        }

        function addMissionObjectives() {
            // Server room (mission objective 1)
            const serverRoom = new THREE.Mesh(
                new THREE.BoxGeometry(15, 8, 15),
                new THREE.MeshStandardMaterial({ 
                    color: 0x1a6a3a,
                    emissive: 0x0a3a1a,
                    emissiveIntensity: 0.3
                })
            );
            serverRoom.position.set(-40, 4, 30);
            serverRoom.castShadow = true;
            scene.add(serverRoom);
            
            // Add server racks inside
            for (let i = 0; i < 3; i++) {
                const server = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 6, 1),
                    new THREE.MeshStandardMaterial({ color: 0x333333 })
                );
                server.position.set(-40 + (i - 1) * 3, 3, 30);
                scene.add(server);
            }
            
            // Intel data center (mission objective 2)
            const intelBuilding = new THREE.Mesh(
                new THREE.CylinderGeometry(6, 6, 12, 8),
                new THREE.MeshStandardMaterial({ 
                    color: 0x6a3a1a,
                    emissive: 0x3a1a0a,
                    emissiveIntensity: 0.3
                })
            );
            intelBuilding.position.set(40, 6, -30);
            intelBuilding.castShadow = true;
            scene.add(intelBuilding);
            
            // Add antenna
            const antenna = new THREE.Mesh(
                new THREE.ConeGeometry(0.5, 4, 4),
                new THREE.MeshStandardMaterial({ color: 0xaaaaaa })
            );
            antenna.position.set(40, 12, -30);
            scene.add(antenna);
        }

        function createPlaceholderPlayers() {
            const playerColors = [0x4361ee, 0xf72585, 0x4ade80, 0xf59e0b];
            
            // Create current player
            const playerGeometry = new THREE.CapsuleGeometry(0.5, 2, 4, 8);
            const playerMaterial = new THREE.MeshStandardMaterial({ 
                color: playerColors[0],
                emissive: playerColors[0],
                emissiveIntensity: 0.1
            });
            
            const playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
            playerMesh.position.set(0, 1, 0);
            playerMesh.castShadow = true;
            scene.add(playerMesh);
            
            playerObjects[gameState.playerId] = {
                mesh: playerMesh,
                name: gameState.playerName,
                health: 100,
                position: { x: 0, y: 1, z: 0 }
            };
            
            // Create other players
            const otherPlayers = Object.values(gameState.players).filter(p => p.id !== gameState.playerId);
            otherPlayers.forEach((player, index) => {
                const otherPlayerMesh = new THREE.Mesh(playerGeometry, new THREE.MeshStandardMaterial({ 
                    color: playerColors[(index + 1) % playerColors.length],
                    emissive: playerColors[(index + 1) % playerColors.length],
                    emissiveIntensity: 0.1
                }));
                
                const positions = [
                    { x: 20, z: 0 },
                    { x: -20, z: 0 },
                    { x: 0, z: 20 }
                ];
                const pos = positions[index] || { x: 10, z: 10 };
                
                otherPlayerMesh.position.set(pos.x, 1, pos.z);
                otherPlayerMesh.castShadow = true;
                scene.add(otherPlayerMesh);
                
                playerObjects[player.id] = {
                    mesh: otherPlayerMesh,
                    name: player.name,
                    health: 100,
                    position: { x: pos.x, y: 1, z: pos.z }
                };
            });
            
            addPlayerLabels();
        }

        function createPlaceholderEnemies() {
            const enemyGeometry = new THREE.ConeGeometry(0.6, 2, 8);
            
            for (let i = 0; i < 12; i++) {
                const enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xaa3333,
                    emissive: 0xaa3333,
                    emissiveIntensity: 0.1
                });
                
                const enemyMesh = new THREE.Mesh(enemyGeometry, enemyMaterial);
                
                // Distribute enemies around objectives
                let x, z;
                if (i < 4) {
                    // Around server room
                    x = -40 + (Math.random() - 0.5) * 20;
                    z = 30 + (Math.random() - 0.5) * 20;
                } else if (i < 8) {
                    // Around intel building
                    x = 40 + (Math.random() - 0.5) * 20;
                    z = -30 + (Math.random() - 0.5) * 20;
                } else {
                    // Random patrol
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 20 + Math.random() * 30;
                    x = Math.cos(angle) * radius;
                    z = Math.sin(angle) * radius;
                }
                
                enemyMesh.position.set(x, 1, z);
                enemyMesh.castShadow = true;
                scene.add(enemyMesh);
                
                enemyObjects.push({
                    mesh: enemyMesh,
                    health: 100,
                    position: { x, y: 1, z },
                    alive: true,
                    patrolAngle: Math.random() * Math.PI * 2,
                    patrolSpeed: 0.5 + Math.random() * 1
                });
            }
        }

        function createExtractionZone() {
            const extractionGeometry = new THREE.CylinderGeometry(8, 8, 0.2, 32);
            const extractionMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4ade80,
                emissive: 0x4ade80,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.6
            });
            
            extractionZone = new THREE.Mesh(extractionGeometry, extractionMaterial);
            extractionZone.position.set(0, 0.1, 0); // Center of map
            scene.add(extractionZone);
            
            extractionZone.userData.pulseDirection = 1;
            extractionZone.userData.originalOpacity = 0.6;
        }

        // Rest of the game functions (same as before, but using placeholder versions)
        // [Include all previous game logic functions here, adjusted to use the placeholder versions]

        // Helper functions for notifications, etc.
        function showNotification(title, message, duration = 5000) {
            const notificationArea = document.getElementById('notificationArea');
            
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.innerHTML = `
                <div class="notification-title">${title}</div>
                <div class="notification-message">${message}</div>
            `;
            
            notificationArea.appendChild(notification);
            
            setTimeout(() => notification.classList.add('show'), 10);
            
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 500);
            }, duration);
        }

        // Note: Due to character limits, I've provided the key structural changes.
        // The complete implementation would include all the networking logic from the previous version,
        // adapted to work with the new asset loading system.
    </script>
</body>
</html>
