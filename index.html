<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mission Extraction - Local Network Multiplayer</title>
    <style>
        /* Reset & Base */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-tap-highlight-color: transparent;
            -webkit-font-smoothing: antialiased;
        }
        
        body {
            background: linear-gradient(135deg, #0c0c1d 0%, #1a1a2e 100%);
            color: #e0e0ff;
            min-height: 100vh;
            overflow: hidden;
            user-select: none;
            touch-action: none;
        }
        
        /* Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 20px;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            overflow-y: auto;
            z-index: 10;
        }
        
        .screen.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 1;
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Main Menu */
        .title {
            font-size: clamp(2.5rem, 5vw, 3.5rem);
            font-weight: 800;
            text-align: center;
            margin-bottom: 15px;
            background: linear-gradient(90deg, #4cc9f0, #4361ee);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 20px rgba(76, 201, 240, 0.3);
            letter-spacing: 1px;
        }
        
        .subtitle {
            font-size: clamp(1rem, 2vw, 1.2rem);
            margin-bottom: 30px;
            text-align: center;
            color: #a0a0ff;
            max-width: 600px;
            line-height: 1.5;
        }
        
        /* Room Controls */
        .room-controls {
            background: linear-gradient(145deg, rgba(20, 20, 40, 0.9), rgba(10, 10, 25, 0.9));
            border-radius: 16px;
            padding: clamp(20px, 4vw, 30px);
            width: 100%;
            max-width: 500px;
            border: 1px solid rgba(76, 201, 240, 0.2);
            box-shadow: 
                0 10px 30px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            margin-bottom: 25px;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #4cc9f0;
            font-size: 0.95rem;
        }
        
        .input-group input {
            width: 100%;
            padding: 14px 16px;
            background: rgba(5, 5, 15, 0.8);
            border: 1px solid #4361ee;
            border-radius: 10px;
            color: white;
            font-size: 1.1rem;
            letter-spacing: 1px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .input-group input:focus {
            outline: none;
            border-color: #4cc9f0;
            box-shadow: 0 0 15px rgba(76, 201, 240, 0.3);
            transform: translateY(-1px);
        }
        
        .input-group input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        
        /* Buttons */
        .btn {
            display: block;
            width: 100%;
            padding: 16px;
            margin-top: 12px;
            background: linear-gradient(135deg, #4361ee, #3a0ca3);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            letter-spacing: 0.5px;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        
        .btn:hover::before {
            width: 300px;
            height: 300px;
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 
                0 7px 20px rgba(67, 97, 238, 0.4),
                0 3px 10px rgba(67, 97, 238, 0.2);
        }
        
        .btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(67, 97, 238, 0.3);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #f72585, #b5179e);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #4ade80, #16a34a);
        }
        
        .btn-warning {
            background: linear-gradient(135deg, #f59e0b, #d97706);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #ef4444, #dc2626);
        }
        
        /* File Upload */
        .file-upload {
            background: rgba(30, 30, 60, 0.6);
            border: 2px dashed #4361ee;
            border-radius: 12px;
            padding: 30px 20px;
            text-align: center;
            margin: 20px 0;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .file-upload::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                45deg,
                transparent,
                rgba(76, 201, 240, 0.1),
                transparent
            );
            transform: rotate(45deg);
            transition: transform 0.6s;
        }
        
        .file-upload:hover::after {
            transform: rotate(45deg) translate(10%, 10%);
        }
        
        .file-upload:hover {
            border-color: #4cc9f0;
            background: rgba(40, 40, 70, 0.7);
            transform: translateY(-2px);
        }
        
        .file-upload.dragover {
            border-color: #4ade80;
            background: rgba(40, 70, 40, 0.6);
            animation: pulseBorder 1s infinite;
        }
        
        @keyframes pulseBorder {
            0%, 100% { border-color: #4ade80; }
            50% { border-color: #4cc9f0; }
        }
        
        .file-upload h3 {
            color: #4cc9f0;
            margin-bottom: 8px;
            font-size: 1.3rem;
        }
        
        .file-upload p {
            color: #a0a0ff;
            font-size: 0.95rem;
            margin-bottom: 5px;
        }
        
        .file-list {
            margin-top: 20px;
            max-height: 220px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #4361ee rgba(20, 20, 40, 0.8);
        }
        
        .file-list::-webkit-scrollbar {
            width: 6px;
        }
        
        .file-list::-webkit-scrollbar-track {
            background: rgba(20, 20, 40, 0.8);
            border-radius: 3px;
        }
        
        .file-list::-webkit-scrollbar-thumb {
            background: #4361ee;
            border-radius: 3px;
        }
        
        .file-item {
            background: linear-gradient(90deg, rgba(20, 20, 40, 0.8), rgba(30, 30, 60, 0.8));
            border-radius: 10px;
            padding: 12px 15px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            border-left: 4px solid #4361ee;
            transition: all 0.3s ease;
        }
        
        .file-item:hover {
            transform: translateX(5px);
            background: linear-gradient(90deg, rgba(30, 30, 60, 0.9), rgba(40, 40, 80, 0.9));
        }
        
        .file-item.required {
            border-left-color: #f59e0b;
        }
        
        .file-item.loaded {
            border-left-color: #4ade80;
        }
        
        .file-icon {
            margin-right: 12px;
            font-size: 1.5rem;
            min-width: 30px;
        }
        
        .file-info {
            flex: 1;
            min-width: 0;
        }
        
        .file-name {
            font-weight: 600;
            font-size: 1rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .file-size {
            font-size: 0.85rem;
            color: #a0a0ff;
            margin-top: 2px;
        }
        
        .file-status {
            font-size: 0.8rem;
            padding: 4px 10px;
            border-radius: 12px;
            background: rgba(67, 97, 238, 0.2);
            color: #a0a0ff;
            font-weight: 600;
            min-width: 80px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        /* Waiting Room */
        .players-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            width: 100%;
            max-width: 800px;
            margin: 25px 0;
        }
        
        .player-card {
            background: linear-gradient(145deg, rgba(30, 30, 60, 0.8), rgba(20, 20, 40, 0.8));
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .player-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #4361ee, #4cc9f0);
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }
        
        .player-card.ready::before {
            transform: scaleX(1);
        }
        
        .player-card.ready {
            border-color: #4ade80;
            box-shadow: 
                0 5px 15px rgba(74, 222, 128, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        
        .player-card.host {
            border-color: #4cc9f0;
            box-shadow: 
                0 5px 15px rgba(76, 201, 240, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        
        .player-card.downloading {
            border-color: #f59e0b;
            animation: downloadingPulse 2s infinite;
        }
        
        @keyframes downloadingPulse {
            0%, 100% { box-shadow: 0 0 0 rgba(245, 158, 11, 0.2); }
            50% { box-shadow: 0 0 20px rgba(245, 158, 11, 0.4); }
        }
        
        .player-avatar {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            margin: 0 auto 15px;
            background: linear-gradient(135deg, #4361ee, #3a0ca3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        .player-avatar::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                45deg,
                transparent,
                rgba(255, 255, 255, 0.1),
                transparent
            );
            transform: rotate(45deg);
        }
        
        .player-name {
            font-weight: 600;
            margin-bottom: 10px;
            color: #e0e0ff;
            font-size: 1.1rem;
        }
        
        .player-status {
            font-size: 0.85rem;
            padding: 6px 12px;
            border-radius: 20px;
            display: inline-block;
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        
        .status-ready {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.2), rgba(74, 222, 128, 0.1));
            color: #4ade80;
            border: 1px solid rgba(74, 222, 128, 0.3);
        }
        
        .status-waiting {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.2), rgba(245, 158, 11, 0.1));
            color: #f59e0b;
            border: 1px solid rgba(245, 158, 11, 0.3);
        }
        
        .status-downloading {
            background: linear-gradient(135deg, rgba(67, 97, 238, 0.2), rgba(67, 97, 238, 0.1));
            color: #4361ee;
            border: 1px solid rgba(67, 97, 238, 0.3);
        }
        
        /* Game Screen */
        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        .game-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            gap: 20px;
            pointer-events: none;
            z-index: 100;
        }
        
        .ui-panel {
            background: linear-gradient(145deg, rgba(20, 20, 40, 0.85), rgba(10, 10, 25, 0.85));
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(76, 201, 240, 0.2);
            min-width: 220px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease;
        }
        
        .ui-panel:hover {
            transform: translateY(-2px);
        }
        
        .ui-panel h3 {
            color: #4cc9f0;
            margin-bottom: 10px;
            font-size: 1.1rem;
            border-bottom: 1px solid rgba(76, 201, 240, 0.2);
            padding-bottom: 8px;
        }
        
        .ui-panel p {
            margin: 8px 0;
            font-size: 0.95rem;
            color: #e0e0ff;
        }
        
        .ui-panel p span {
            color: #4ade80;
            font-weight: 600;
        }
        
        .mission-list {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: linear-gradient(145deg, rgba(20, 20, 40, 0.85), rgba(10, 10, 25, 0.85));
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(76, 201, 240, 0.2);
            width: min(350px, 90vw);
            backdrop-filter: blur(10px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            max-height: 300px;
            overflow-y: auto;
            pointer-events: auto;
        }
        
        .mission-list h3 {
            color: #4cc9f0;
            margin-bottom: 12px;
            font-size: 1.1rem;
        }
        
        .mission-item {
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            align-items: center;
            transition: all 0.3s ease;
        }
        
        .mission-item:hover {
            transform: translateX(5px);
        }
        
        .mission-item.completed {
            color: #4ade80;
        }
        
        .mission-checkbox {
            margin-right: 12px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #4361ee;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .mission-item.completed .mission-checkbox {
            background: #4ade80;
            border-color: #4ade80;
        }
        
        .mission-item.completed .mission-checkbox::after {
            content: '‚úì';
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
        
        .extraction-timer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(145deg, rgba(20, 20, 40, 0.85), rgba(10, 10, 25, 0.85));
            border-radius: 12px;
            padding: 15px 30px;
            border: 1px solid rgba(76, 201, 240, 0.2);
            font-size: 1.4rem;
            font-weight: 700;
            color: #4cc9f0;
            text-align: center;
            backdrop-filter: blur(10px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            min-width: 250px;
            pointer-events: auto;
            z-index: 100;
        }
        
        /* Controls Overlay */
        .controls-overlay {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(145deg, rgba(20, 20, 40, 0.85), rgba(10, 10, 25, 0.85));
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(76, 201, 240, 0.2);
            width: min(300px, 90vw);
            backdrop-filter: blur(10px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            pointer-events: auto;
            z-index: 100;
        }
        
        .controls-overlay h3 {
            color: #4cc9f0;
            margin-bottom: 12px;
            font-size: 1.1rem;
        }
        
        .control-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .control-key {
            background: rgba(67, 97, 238, 0.2);
            padding: 4px 8px;
            border-radius: 6px;
            font-family: monospace;
            font-weight: bold;
        }
        
        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0c0c1d, #1a1a2e);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        
        .loading-progress-container {
            width: min(400px, 80vw);
            margin: 25px 0;
        }
        
        .loading-progress {
            width: 100%;
            height: 8px;
            background: rgba(20, 20, 40, 0.8);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid #4361ee;
        }
        
        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #4361ee, #4cc9f0);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }
        
        .loading-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            width: 100%;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.3),
                transparent
            );
            animation: shimmer 2s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .loading-file {
            margin-top: 15px;
            color: #a0a0ff;
            font-size: 0.95rem;
            text-align: center;
            min-height: 20px;
        }
        
        .loading-speed {
            font-size: 0.85rem;
            color: #a0a0ff;
            margin-top: 5px;
        }
        
        /* Notifications */
        .notification-area {
            position: fixed;
            top: 20px;
            right: 20px;
            width: min(350px, 90vw);
            z-index: 3000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }
        
        .notification {
            background: linear-gradient(145deg, rgba(20, 20, 40, 0.95), rgba(10, 10, 25, 0.95));
            border-radius: 12px;
            padding: 15px;
            border-left: 5px solid #4361ee;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
            transform: translateX(400px);
            transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        .notification-title {
            font-weight: 600;
            margin-bottom: 5px;
            color: #4cc9f0;
            font-size: 1rem;
        }
        
        .notification-message {
            color: #e0e0ff;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        
        /* Code Display */
        .code-display {
            font-size: 3.5rem;
            font-weight: 800;
            letter-spacing: 15px;
            text-align: center;
            background: linear-gradient(145deg, rgba(10, 10, 25, 0.9), rgba(20, 20, 40, 0.9));
            padding: 25px 40px;
            border-radius: 16px;
            margin: 25px 0;
            color: #4ade80;
            border: 2px solid #4361ee;
            box-shadow: 
                0 10px 30px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            text-shadow: 0 0 20px rgba(74, 222, 128, 0.3);
        }
        
        /* Instructions */
        .instructions {
            background: linear-gradient(145deg, rgba(20, 20, 40, 0.6), rgba(10, 10, 25, 0.6));
            border-radius: 12px;
            padding: 20px;
            margin-top: 25px;
            border: 1px solid rgba(76, 201, 240, 0.1);
            max-width: 600px;
            backdrop-filter: blur(5px);
        }
        
        .instructions h3 {
            color: #4cc9f0;
            margin-bottom: 12px;
            font-size: 1.2rem;
        }
        
        .instructions ul {
            padding-left: 20px;
            list-style: none;
        }
        
        .instructions li {
            margin-bottom: 10px;
            line-height: 1.5;
            position: relative;
            padding-left: 25px;
        }
        
        .instructions li::before {
            content: '‚ñ∂';
            position: absolute;
            left: 0;
            color: #4361ee;
            font-size: 0.8rem;
        }
        
        /* Animations */
        .pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .bounce {
            animation: bounce 1s infinite;
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        
        /* Loading Spinner */
        .loader {
            border: 4px solid rgba(67, 97, 238, 0.3);
            border-top: 4px solid #4361ee;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        .loader-small {
            border: 3px solid rgba(67, 97, 238, 0.3);
            border-top: 3px solid #4361ee;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-left: 10px;
            vertical-align: middle;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Utility Classes */
        .hidden {
            display: none !important;
        }
        
        .text-center {
            text-align: center;
        }
        
        .mt-2 { margin-top: 8px; }
        .mt-3 { margin-top: 12px; }
        .mt-4 { margin-top: 16px; }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .room-controls {
                padding: 20px;
            }
            
            .players-list {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }
            
            .game-ui {
                flex-direction: column;
                gap: 10px;
            }
            
            .ui-panel, .mission-list, .controls-overlay {
                width: calc(100% - 40px);
                min-width: unset;
                transform: scale(0.95);
                transform-origin: top left;
            }
            
            .extraction-timer {
                font-size: 1.2rem;
                padding: 12px 20px;
                min-width: 200px;
            }
            
            .code-display {
                font-size: 2.5rem;
                letter-spacing: 10px;
                padding: 20px;
            }
        }
        
        @media (max-width: 480px) {
            .title {
                font-size: 2rem;
            }
            
            .subtitle {
                font-size: 0.9rem;
            }
            
            .btn {
                padding: 14px;
                font-size: 1rem;
            }
            
            .players-list {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Main Menu Screen -->
    <div id="mainMenu" class="screen active">
        <h1 class="title">MISSION EXTRACTION</h1>
        <p class="subtitle">Local Network Co-op Tactical Operations</p>
        
        <div class="room-controls">
            <div class="input-group">
                <label for="playerName">YOUR CALL SIGN</label>
                <input type="text" id="playerName" placeholder="Enter your name" value="Operator" maxlength="12">
            </div>
            
            <button id="createRoomBtn" class="btn">CREATE ROOM</button>
            <button id="joinRoomBtn" class="btn btn-secondary">JOIN ROOM</button>
        </div>
        
        <div class="instructions">
            <h3>HOW TO PLAY:</h3>
            <ul>
                <li>One player creates a room and uploads game assets</li>
                <li>Other players join using the 4-digit room code</li>
                <li>Complete missions: eliminate enemies, secure objectives</li>
                <li>Meet at extraction point after 2 minutes</li>
                <li>All players must extract together to win</li>
            </ul>
        </div>
    </div>
    
    <!-- Host Room Screen -->
    <div id="hostRoomScreen" class="screen">
        <h1 class="title">HOST ROOM</h1>
        <p class="subtitle">Upload game assets to create room</p>
        
        <div class="room-controls">
            <div class="input-group">
                <label>REQUIRED GAME ASSETS</label>
                <p style="color: #a0a0ff; font-size: 0.9rem; margin-top: 5px;">
                    Upload these files from your computer:
                </p>
            </div>
            
            <div class="file-upload" id="fileDropZone">
                <div class="file-icon">üìÅ</div>
                <h3>DRAG & DROP FILES HERE</h3>
                <p>or click to select files</p>
                <p style="font-size: 0.9rem; color: #f59e0b; margin-top: 10px;">
                    Required: map.glb, player1.glb, player2.glb, enemy.glb
                </p>
                <input type="file" id="fileInput" multiple accept=".glb,.gltf" style="display: none;">
            </div>
            
            <div class="file-list" id="fileList">
                <div class="file-item required">
                    <div class="file-icon">üó∫Ô∏è</div>
                    <div class="file-info">
                        <div class="file-name">map.glb</div>
                        <div class="file-size">Required - 3D Map File</div>
                    </div>
                    <div class="file-status" id="mapStatus">Missing</div>
                </div>
                <div class="file-item required">
                    <div class="file-icon">üë§</div>
                    <div class="file-info">
                        <div class="file-name">player1.glb</div>
                        <div class="file-size">Required - Player 1 Model</div>
                    </div>
                    <div class="file-status" id="player1Status">Missing</div>
                </div>
                <div class="file-item required">
                    <div class="file-icon">üë§</div>
                    <div class="file-info">
                        <div class="file-name">player2.glb</div>
                        <div class="file-size">Required - Player 2 Model</div>
                    </div>
                    <div class="file-status" id="player2Status">Missing</div>
                </div>
                <div class="file-item required">
                    <div class="file-icon">üëæ</div>
                    <div class="file-info">
                        <div class="file-name">enemy.glb</div>
                        <div class="file-size">Required - Enemy Model</div>
                    </div>
                    <div class="file-status" id="enemyStatus">Missing</div>
                </div>
            </div>
            
            <button id="createRoomWithAssets" class="btn btn-success" disabled>CREATE ROOM WITH ASSETS</button>
            <button id="backToMainFromHost" class="btn btn-secondary">BACK</button>
        </div>
    </div>
    
    <!-- Room Created Screen -->
    <div id="roomCreatedScreen" class="screen">
        <h1 class="title">ROOM CREATED</h1>
        <p class="subtitle">Share this code with other players on your local network</p>
        
        <div class="code-display" id="roomCode">----</div>
        
        <div class="room-controls">
            <p style="margin-bottom: 15px;">Waiting for players to join...</p>
            <p style="color: #4cc9f0; margin: 10px 0; font-size: 1.2rem;">
                <span id="connectedPlayers">0</span> player(s) connected
            </p>
            <div class="loader"></div>
            <button id="goToWaitingRoom" class="btn btn-success hidden">GO TO WAITING ROOM</button>
        </div>
    </div>
    
    <!-- Join Room Screen -->
    <div id="joinRoomScreen" class="screen">
        <h1 class="title">JOIN ROOM</h1>
        <p class="subtitle">Enter the 4-digit room code provided by the host</p>
        
        <div class="room-controls">
            <div class="input-group">
                <label for="joinCodeInput">ROOM CODE</label>
                <input type="text" id="joinCodeInput" placeholder="Enter 4-digit code" maxlength="4" pattern="\d{4}">
            </div>
            
            <button id="joinWithCodeBtn" class="btn">JOIN</button>
            <button id="backToMainBtn" class="btn btn-secondary">BACK</button>
        </div>
    </div>
    
    <!-- Waiting Room Screen -->
    <div id="waitingRoomScreen" class="screen">
        <h1 class="title">WAITING ROOM</h1>
        <p class="subtitle" id="roomCodeDisplay">Room Code: ----</p>
        
        <div class="players-list" id="playersList">
            <!-- Player cards will be inserted here -->
        </div>
        
        <div class="room-controls">
            <div id="playerStatus">
                <!-- Download status for joining players -->
                <div id="downloadStatus" class="hidden">
                    <p style="margin-bottom: 10px; color: #4cc9f0; font-size: 1.1rem;">
                        <span id="downloadProgress">Downloading assets from host...</span>
                        <span class="loader-small"></span>
                    </p>
                    <div class="loading-progress">
                        <div class="loading-bar" id="downloadBar"></div>
                    </div>
                    <p id="downloadSpeed" class="loading-speed"></p>
                </div>
                
                <!-- Ready button for ALL players -->
                <button id="readyBtn" class="btn">READY</button>
                
                <!-- Host-only controls (shown when all players are ready) -->
                <div id="hostControls" class="hidden">
                    <p id="hostMessage" style="margin: 15px 0; color: #4ade80; text-align: center; font-size: 1.1rem;">
                        All players are ready!
                    </p>
                    <button id="startMissionBtn" class="btn btn-success">LAUNCH MISSION</button>
                </div>
            </div>
            <button id="leaveWaitingRoomBtn" class="btn btn-secondary">LEAVE ROOM</button>
        </div>
    </div>
    
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen hidden">
        <h1 class="title">LOADING GAME</h1>
        <div class="loading-progress-container">
            <div class="loading-progress">
                <div class="loading-bar" id="loadingBar"></div>
            </div>
        </div>
        <div class="loading-file" id="loadingFile">Initializing game engine...</div>
        <div class="loader"></div>
    </div>
    
    <!-- Game Screen -->
    <div id="gameScreen" class="screen">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Game UI Overlay -->
        <div class="game-ui">
            <div class="ui-panel">
                <h3>OPERATOR STATUS</h3>
                <p>Player: <span id="uiPlayerName">---</span></p>
                <p>Health: <span id="uiHealth">100</span></p>
                <p>Enemies: <span id="uiKills">0</span>/10</p>
                <p>Objectives: <span id="uiObjectives">0</span>/3</p>
            </div>
            
            <div class="ui-panel">
                <h3>TEAM STATUS</h3>
                <div id="teamStatus">
                    <!-- Team member status will be inserted here -->
                </div>
            </div>
        </div>
        
        <div class="extraction-timer">
            Extraction Available In: <span id="extractionTimer">02:00</span>
        </div>
        
        <div class="mission-list">
            <h3>ACTIVE MISSIONS</h3>
            <div class="mission-item" id="mission1">
                <div class="mission-checkbox"></div>
                <span>Eliminate 10 enemies (0/10)</span>
            </div>
            <div class="mission-item" id="mission2">
                <div class="mission-checkbox"></div>
                <span>Secure server room</span>
            </div>
            <div class="mission-item" id="mission3">
                <div class="mission-checkbox"></div>
                <span>Download intel data</span>
            </div>
            <div class="mission-item" id="mission4">
                <div class="mission-checkbox"></div>
                <span>Extract with partner</span>
            </div>
        </div>
        
        <!-- Controls Overlay -->
        <div class="controls-overlay">
            <h3>CONTROLS</h3>
            <div class="control-item">
                <span>Move:</span>
                <span class="control-key">WASD</span>
            </div>
            <div class="control-item">
                <span>Run:</span>
                <span class="control-key">SHIFT</span>
            </div>
            <div class="control-item">
                <span>Jump:</span>
                <span class="control-key">SPACE</span>
            </div>
            <div class="control-item">
                <span>Look:</span>
                <span class="control-key">MOUSE</span>
            </div>
            <div class="control-item">
                <span>Mission 1:</span>
                <span class="control-key">1</span>
            </div>
            <div class="control-item">
                <span>Mission 2:</span>
                <span class="control-key">2</span>
            </div>
            <div class="control-item">
                <span>Mission 3:</span>
                <span class="control-key">3</span>
            </div>
            <div class="control-item">
                <span>Extract:</span>
                <span class="control-key">4</span>
            </div>
        </div>
    </div>
    
    <!-- Notification System -->
    <div class="notification-area" id="notificationArea"></div>

    <!-- Three.js - Updated to latest version for better features -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    
    <script>
        // ======================
        // CONFIGURATION
        // ======================
        const CONFIG = {
            ROOM_CODE_LENGTH: 4,
            MAX_PLAYERS: 4,
            EXTRACTION_TIME_MINUTES: 2,
            LOCAL_STORAGE_KEY: 'mission_extraction_rooms',
            REQUIRED_ASSETS: ['map', 'player1', 'player2', 'enemy'],
            CHUNK_SIZE: 16384,
            ASSET_CHECK_INTERVAL: 1000,
            ROOM_UPDATE_INTERVAL: 1000,
            GAME_TICK_RATE: 60,
            DEBUG: false,
            PLAYER_SPEED: 5,
            PLAYER_RUN_SPEED: 10,
            PLAYER_JUMP_FORCE: 10,
            GRAVITY: 30,
            MOUSE_SENSITIVITY: 0.002
        };

        // ======================
        // GAME STATE
        // ======================
        const gameState = {
            // Player State
            playerId: null,
            playerName: 'Operator',
            roomCode: null,
            isHost: false,
            isReady: false,
            
            // Room State
            players: {},
            peerConnections: {},
            dataChannels: {},
            
            // Game State
            currentScreen: 'mainMenu',
            gameStarted: false,
            gameTime: 0,
            frameCount: 0,
            gameLoopRunning: false,
            gamePaused: false,
            
            // Assets
            assetFiles: {},
            receivedAssets: {},
            loadedModels: {},
            
            // Missions
            missions: {
                enemiesKilled: 0,
                serverSecured: false,
                intelDownloaded: false,
                extractionReady: false
            },
            
            // Timer
            extractionTimer: CONFIG.EXTRACTION_TIME_MINUTES * 60,
            extractionAvailable: false,
            
            // Performance
            fps: 0,
            lastFpsUpdate: 0,
            
            // Player Movement
            keys: {
                w: false,
                a: false,
                s: false,
                d: false,
                shift: false,
                space: false
            },
            mouse: {
                x: 0,
                y: 0,
                sensitivity: CONFIG.MOUSE_SENSITIVITY
            },
            velocity: new THREE.Vector3(),
            direction: new THREE.Vector3(),
            rotation: new THREE.Euler(0, 0, 0, 'YXZ'),
            
            // Physics
            playerOnGround: true,
            playerVelocityY: 0
        };

        // ======================
        // THREE.JS VARIABLES
        // ======================
        let scene = null;
        let camera = null;
        let renderer = null;
        let controls = null;
        let playerObjects = {};
        let enemyObjects = [];
        let mapObject = null;
        let extractionZone = null;
        let clock = new THREE.Clock();
        let deltaTime = 0;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        // ======================
        // DOM ELEMENTS
        // ======================
        const screens = {
            mainMenu: document.getElementById('mainMenu'),
            hostRoomScreen: document.getElementById('hostRoomScreen'),
            roomCreatedScreen: document.getElementById('roomCreatedScreen'),
            joinRoomScreen: document.getElementById('joinRoomScreen'),
            waitingRoomScreen: document.getElementById('waitingRoomScreen'),
            gameScreen: document.getElementById('gameScreen')
        };

        // ======================
        // INITIALIZATION
        // ======================
        document.addEventListener('DOMContentLoaded', initGame);

        function initGame() {
            console.log('Initializing game...');
            
            initEventListeners();
            generatePlayerId();
            loadPlayerName();
            
            console.log('Game initialized');
        }

        function initEventListeners() {
            // Main Menu
            document.getElementById('createRoomBtn').addEventListener('click', () => showScreen('hostRoomScreen'));
            document.getElementById('joinRoomBtn').addEventListener('click', () => showScreen('joinRoomScreen'));
            
            // Host Room Screen
            const fileInput = document.getElementById('fileInput');
            const fileDropZone = document.getElementById('fileDropZone');
            
            fileInput.addEventListener('change', handleFileSelect);
            fileDropZone.addEventListener('click', () => fileInput.click());
            document.getElementById('createRoomWithAssets').addEventListener('click', createRoomWithAssets);
            document.getElementById('backToMainFromHost').addEventListener('click', showMainMenu);
            
            // Drag and Drop
            setupDragAndDrop(fileDropZone);
            
            // Join Room Screen
            document.getElementById('joinWithCodeBtn').addEventListener('click', joinRoom);
            document.getElementById('backToMainBtn').addEventListener('click', showMainMenu);
            document.getElementById('joinCodeInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') joinRoom();
            });
            
            // Waiting Room
            document.getElementById('readyBtn').addEventListener('click', toggleReady);
            document.getElementById('startMissionBtn').addEventListener('click', startGame);
            document.getElementById('leaveWaitingRoomBtn').addEventListener('click', leaveWaitingRoom);
            document.getElementById('goToWaitingRoom').addEventListener('click', goToWaitingRoom);
            
            // Player Name
            document.getElementById('playerName').addEventListener('input', (e) => {
                gameState.playerName = e.target.value.trim() || 'Operator';
                localStorage.setItem('playerName', gameState.playerName);
            });
            
            // Window Events
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('beforeunload', handleBeforeUnload);
            
            // Game Controls will be setup when game starts
        }

        function setupDragAndDrop(dropZone) {
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });
            
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('dragover');
            });
            
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                handleFileSelect({ target: { files: e.dataTransfer.files } });
            });
        }

        // ======================
        // PLAYER MANAGEMENT
        // ======================
        function generatePlayerId() {
            gameState.playerId = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            console.log('Player ID generated:', gameState.playerId);
        }

        function loadPlayerName() {
            const savedName = localStorage.getItem('playerName');
            if (savedName) {
                gameState.playerName = savedName;
                document.getElementById('playerName').value = savedName;
            }
        }

        // ======================
        // SCREEN MANAGEMENT
        // ======================
        function showScreen(screenName) {
            console.log('Showing screen:', screenName);
            
            // Hide all screens
            Object.values(screens).forEach(screen => {
                screen.classList.remove('active');
            });
            
            // Show requested screen
            if (screens[screenName]) {
                screens[screenName].classList.add('active');
                gameState.currentScreen = screenName;
            }
        }

        function showMainMenu() {
            resetGameState();
            showScreen('mainMenu');
        }

        function resetGameState() {
            gameState.roomCode = null;
            gameState.isHost = false;
            gameState.isReady = false;
            gameState.players = {};
            gameState.assetFiles = {};
            gameState.receivedAssets = {};
            gameState.gameStarted = false;
            gameState.gameLoopRunning = false;
            gameState.loadedModels = {};
        }

        // ======================
        // FILE HANDLING
        // ======================
        function handleFileSelect(event) {
            const files = Array.from(event.target.files);
            let allRequiredFound = true;
            
            console.log('Files selected:', files.length);
            
            // Reset file status
            CONFIG.REQUIRED_ASSETS.forEach(asset => {
                gameState.assetFiles[asset] = null;
                updateFileStatus(asset, 'Missing', 'Required');
            });
            
            files.forEach(file => {
                const fileName = file.name.toLowerCase();
                let assetType = null;
                
                // Match files to asset types
                if (fileName.includes('map') || fileName.endsWith('.glb') || fileName.endsWith('.gltf')) {
                    if (fileName.includes('map')) assetType = 'map';
                    else if (fileName.includes('player1')) assetType = 'player1';
                    else if (fileName.includes('player2')) assetType = 'player2';
                    else if (fileName.includes('enemy')) assetType = 'enemy';
                }
                
                if (assetType) {
                    gameState.assetFiles[assetType] = file;
                    updateFileStatus(assetType, 'loaded', formatFileSize(file.size));
                    showNotification('File Loaded', `${file.name} loaded successfully`, 3000);
                }
            });
            
            // Check all required assets
            CONFIG.REQUIRED_ASSETS.forEach(asset => {
                if (!gameState.assetFiles[asset]) {
                    allRequiredFound = false;
                }
            });
            
            // Update create room button
            const createBtn = document.getElementById('createRoomWithAssets');
            createBtn.disabled = !allRequiredFound;
            
            if (allRequiredFound) {
                createBtn.classList.add('pulse');
                showNotification('All Assets Ready', 'You can now create the room!', 5000);
            }
        }

        function updateFileStatus(assetType, status, size = '') {
            const element = document.getElementById(assetType + 'Status');
            const fileItem = document.querySelector(`#fileList .file-item:nth-child(${CONFIG.REQUIRED_ASSETS.indexOf(assetType) + 1})`);
            
            if (!element || !fileItem) return;
            
            element.textContent = status;
            
            if (status === 'loaded') {
                element.style.background = 'linear-gradient(135deg, rgba(74, 222, 128, 0.2), rgba(74, 222, 128, 0.1))';
                element.style.color = '#4ade80';
                element.style.border = '1px solid rgba(74, 222, 128, 0.3)';
                fileItem.classList.add('loaded');
                
                if (size) {
                    const sizeElement = fileItem.querySelector('.file-size');
                    if (sizeElement) sizeElement.textContent = size;
                }
            } else if (status === 'Missing') {
                element.style.background = 'rgba(245, 158, 11, 0.2)';
                element.style.color = '#f59e0b';
                element.style.border = '1px solid rgba(245, 158, 11, 0.3)';
                fileItem.classList.remove('loaded');
            }
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const units = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(1024));
            return (bytes / Math.pow(1024, i)).toFixed(2) + ' ' + units[i];
        }

        // ======================
        // ROOM MANAGEMENT
        // ======================
        function createRoomWithAssets() {
            // Generate room code
            gameState.roomCode = Math.floor(1000 + Math.random() * 9000).toString();
            gameState.isHost = true;
            
            console.log('Creating room:', gameState.roomCode);
            
            // Create room data
            const roomData = {
                code: gameState.roomCode,
                hostId: gameState.playerId,
                hostName: gameState.playerName,
                players: [{
                    id: gameState.playerId,
                    name: gameState.playerName,
                    isReady: false,
                    isHost: true,
                    assetsLoaded: true
                }],
                assets: CONFIG.REQUIRED_ASSETS.reduce((acc, asset) => {
                    acc[asset] = gameState.assetFiles[asset] ? {
                        name: gameState.assetFiles[asset].name,
                        size: gameState.assetFiles[asset].size,
                        type: gameState.assetFiles[asset].type,
                        lastModified: gameState.assetFiles[asset].lastModified
                    } : null;
                    return acc;
                }, {}),
                gameStarted: false,
                createdAt: Date.now(),
                lastUpdated: Date.now()
            };
            
            saveRoomData(roomData);
            
            // Update UI
            document.getElementById('roomCode').textContent = gameState.roomCode;
            showScreen('roomCreatedScreen');
            
            // Start checking for players
            startRoomMonitoring();
        }

        function startRoomMonitoring() {
            const interval = setInterval(() => {
                const roomData = getRoomData(gameState.roomCode);
                
                if (!roomData) {
                    clearInterval(interval);
                    showNotification('Room Error', 'Room data corrupted');
                    return;
                }
                
                // Update connected players count
                const playerCount = roomData.players.length - 1;
                document.getElementById('connectedPlayers').textContent = playerCount;
                
                // Show waiting room button when players join
                if (playerCount >= 1) {
                    document.getElementById('goToWaitingRoom').classList.remove('hidden');
                    clearInterval(interval);
                }
            }, CONFIG.ASSET_CHECK_INTERVAL);
        }

        function goToWaitingRoom() {
            const roomData = getRoomData(gameState.roomCode);
            if (!roomData) return;
            
            gameState.players = roomData.players.reduce((acc, player) => {
                acc[player.id] = player;
                return acc;
            }, {});
            
            document.getElementById('roomCodeDisplay').textContent = `Room Code: ${gameState.roomCode}`;
            updatePlayersList();
            showScreen('waitingRoomScreen');
            
            // Start polling for room updates
            startRoomPolling();
        }

        function joinRoom() {
            const codeInput = document.getElementById('joinCodeInput');
            const code = codeInput.value.trim();
            
            // Validate code
            if (code.length !== CONFIG.ROOM_CODE_LENGTH || !/^\d{4}$/.test(code)) {
                showNotification('Invalid Code', 'Please enter a valid 4-digit room code.');
                codeInput.focus();
                return;
            }
            
            gameState.roomCode = code;
            
            const roomData = getRoomData(code);
            
            if (!roomData) {
                showNotification('Room Not Found', 'No room found with that code.');
                return;
            }
            
            if (roomData.gameStarted) {
                showNotification('Game In Progress', 'This game has already started.');
                return;
            }
            
            if (roomData.players.length >= CONFIG.MAX_PLAYERS) {
                showNotification('Room Full', 'This room has reached maximum players.');
                return;
            }
            
            // Add player to room
            const playerData = {
                id: gameState.playerId,
                name: gameState.playerName,
                isReady: false,
                isHost: false,
                assetsLoaded: false
            };
            
            roomData.players.push(playerData);
            roomData.lastUpdated = Date.now();
            saveRoomData(roomData);
            
            // Update game state
            gameState.isHost = false;
            gameState.players = roomData.players.reduce((acc, player) => {
                acc[player.id] = player;
                return acc;
            }, {});
            
            // Show waiting room
            document.getElementById('roomCodeDisplay').textContent = `Room Code: ${gameState.roomCode}`;
            updatePlayersList();
            showScreen('waitingRoomScreen');
            
            // Start downloading assets
            startAssetDownload(roomData.assets);
            startRoomPolling();
        }

        function startAssetDownload(assets) {
            showNotification('Downloading Assets', 'Starting download from host...');
            
            const downloadStatus = document.getElementById('downloadStatus');
            const readyBtn = document.getElementById('readyBtn');
            
            downloadStatus.classList.remove('hidden');
            readyBtn.textContent = 'WAITING FOR ASSETS';
            readyBtn.disabled = true;
            
            // Simulate download progress
            let totalSize = 0;
            let downloadedSize = 0;
            let startTime = Date.now();
            
            CONFIG.REQUIRED_ASSETS.forEach(asset => {
                if (assets[asset]) {
                    totalSize += assets[asset].size;
                }
            });
            
            const simulateDownload = () => {
                if (downloadedSize < totalSize) {
                    // Calculate download speed
                    const elapsedTime = (Date.now() - startTime) / 1000;
                    const speed = elapsedTime > 0 ? (downloadedSize / 1024 / elapsedTime).toFixed(1) : 0;
                    
                    // Update progress
                    downloadedSize += totalSize / 50; // 2% increments
                    const percent = Math.min(100, (downloadedSize / totalSize) * 100);
                    
                    // Update UI
                    document.getElementById('downloadBar').style.width = percent + '%';
                    document.getElementById('downloadProgress').textContent = 
                        `Downloading assets: ${Math.round(percent)}%`;
                    document.getElementById('downloadSpeed').textContent = 
                        `${speed} KB/s`;
                    
                    // Mark assets as downloaded
                    if (percent >= 25 && !gameState.receivedAssets.map) {
                        gameState.receivedAssets.map = true;
                        showNotification('Map Downloaded', 'Map asset downloaded successfully.');
                    }
                    if (percent >= 50 && !gameState.receivedAssets.player1) {
                        gameState.receivedAssets.player1 = true;
                        showNotification('Player Model Downloaded', 'Player 1 model downloaded.');
                    }
                    if (percent >= 75 && !gameState.receivedAssets.player2) {
                        gameState.receivedAssets.player2 = true;
                        showNotification('Player Model Downloaded', 'Player 2 model downloaded.');
                    }
                    if (percent >= 95 && !gameState.receivedAssets.enemy) {
                        gameState.receivedAssets.enemy = true;
                        showNotification('Enemy Model Downloaded', 'Enemy model downloaded.');
                    }
                    
                    if (percent >= 100) {
                        // Download complete
                        downloadStatus.classList.add('hidden');
                        readyBtn.textContent = 'READY';
                        readyBtn.disabled = false;
                        
                        // Update room data
                        const roomData = getRoomData(gameState.roomCode);
                        if (roomData) {
                            const playerIndex = roomData.players.findIndex(p => p.id === gameState.playerId);
                            if (playerIndex !== -1) {
                                roomData.players[playerIndex].assetsLoaded = true;
                                saveRoomData(roomData);
                            }
                        }
                        
                        showNotification('Assets Ready', 'All game assets downloaded! You can now ready up.');
                        return;
                    }
                    
                    setTimeout(simulateDownload, 100);
                }
            };
            
            simulateDownload();
        }

        function startRoomPolling() {
            const interval = setInterval(() => {
                const roomData = getRoomData(gameState.roomCode);
                
                if (!roomData) {
                    clearInterval(interval);
                    showNotification('Room Closed', 'The host has closed the room.');
                    setTimeout(() => showMainMenu(), 2000);
                    return;
                }
                
                // Update players list
                gameState.players = roomData.players.reduce((acc, player) => {
                    acc[player.id] = player;
                    return acc;
                }, {});
                
                updatePlayersList();
                
                // Check if all players are ready and have assets
                const allPlayersReady = roomData.players.every(p => p.isReady && p.assetsLoaded);
                const atLeastTwoPlayers = roomData.players.length >= 2;
                
                // Update UI based on player role
                const hostControls = document.getElementById('hostControls');
                const readyBtn = document.getElementById('readyBtn');
                const currentPlayer = roomData.players.find(p => p.id === gameState.playerId);
                
                if (gameState.isHost) {
                    if (allPlayersReady && atLeastTwoPlayers) {
                        // Show launch controls
                        hostControls.classList.remove('hidden');
                        readyBtn.classList.add('hidden');
                    } else {
                        // Show ready button
                        hostControls.classList.add('hidden');
                        readyBtn.classList.remove('hidden');
                        readyBtn.textContent = gameState.isReady ? 'NOT READY' : 'READY';
                    }
                } else {
                    // For joining players
                    if (currentPlayer && !currentPlayer.assetsLoaded) {
                        readyBtn.textContent = 'WAITING FOR ASSETS';
                        readyBtn.disabled = true;
                    } else {
                        readyBtn.disabled = false;
                        readyBtn.textContent = gameState.isReady ? 'NOT READY' : 'READY';
                    }
                }
                
                // Check if game started
                if (roomData.gameStarted && !gameState.gameStarted) {
                    clearInterval(interval);
                    gameState.gameStarted = true;
                    loadGameAssets();
                }
            }, CONFIG.ROOM_UPDATE_INTERVAL);
        }

        function updatePlayersList() {
            const playersList = document.getElementById('playersList');
            if (!playersList) return;
            
            playersList.innerHTML = '';
            
            Object.values(gameState.players).forEach(player => {
                const playerCard = document.createElement('div');
                playerCard.className = 'player-card';
                
                if (player.isReady) playerCard.classList.add('ready');
                if (player.isHost) playerCard.classList.add('host');
                if (!player.assetsLoaded && !player.isHost) {
                    playerCard.classList.add('downloading');
                }
                
                let status = player.isReady ? 'READY' : 'WAITING';
                let statusClass = player.isReady ? 'status-ready' : 'status-waiting';
                
                if (!player.assetsLoaded && !player.isHost) {
                    status = 'DOWNLOADING';
                    statusClass = 'status-downloading';
                }
                
                playerCard.innerHTML = `
                    <div class="player-avatar">${player.name.charAt(0).toUpperCase()}</div>
                    <div class="player-name">${player.name} ${player.isHost ? 'üëë' : ''}</div>
                    <div class="player-status ${statusClass}">
                        ${status}
                    </div>
                `;
                
                playersList.appendChild(playerCard);
            });
        }

        function toggleReady() {
            const roomData = getRoomData(gameState.roomCode);
            if (!roomData) return;
            
            const playerIndex = roomData.players.findIndex(p => p.id === gameState.playerId);
            if (playerIndex === -1) return;
            
            // Toggle ready status
            roomData.players[playerIndex].isReady = !roomData.players[playerIndex].isReady;
            gameState.isReady = roomData.players[playerIndex].isReady;
            roomData.lastUpdated = Date.now();
            
            saveRoomData(roomData);
            updatePlayersList();
            
            // Update button
            const readyBtn = document.getElementById('readyBtn');
            readyBtn.textContent = gameState.isReady ? 'NOT READY' : 'READY';
            readyBtn.classList.toggle('btn-secondary', gameState.isReady);
            
            // Show notification
            showNotification(
                gameState.isReady ? 'Ready!' : 'Not Ready',
                gameState.isReady ? 'Waiting for other players...' : 'You can ready up when ready'
            );
        }

        function startGame() {
            if (!gameState.isHost) return;
            
            const roomData = getRoomData(gameState.roomCode);
            if (!roomData) return;
            
            // Verify all conditions
            const allPlayersReady = roomData.players.every(p => p.isReady && p.assetsLoaded);
            const atLeastTwoPlayers = roomData.players.length >= 2;
            
            if (!allPlayersReady || !atLeastTwoPlayers) {
                showNotification('Cannot Start', 'Not all players are ready!');
                return;
            }
            
            // Start the game
            roomData.gameStarted = true;
            roomData.lastUpdated = Date.now();
            saveRoomData(roomData);
            
            loadGameAssets();
        }

        function leaveWaitingRoom() {
            const roomData = getRoomData(gameState.roomCode);
            if (roomData) {
                // Remove player from room
                roomData.players = roomData.players.filter(p => p.id !== gameState.playerId);
                
                // Delete room if empty or host left
                if (roomData.players.length === 0 || (gameState.isHost && roomData.players.length > 0)) {
                    deleteRoomData(gameState.roomCode);
                } else {
                    saveRoomData(roomData);
                }
            }
            
            showMainMenu();
        }

        // ======================
        // LOCAL STORAGE MANAGEMENT
        // ======================
        function saveRoomData(roomData) {
            try {
                const rooms = JSON.parse(localStorage.getItem(CONFIG.LOCAL_STORAGE_KEY) || '{}');
                rooms[roomData.code] = roomData;
                localStorage.setItem(CONFIG.LOCAL_STORAGE_KEY, JSON.stringify(rooms));
            } catch (e) {
                console.error('Failed to save room data:', e);
            }
        }

        function getRoomData(code) {
            try {
                const rooms = JSON.parse(localStorage.getItem(CONFIG.LOCAL_STORAGE_KEY) || '{}');
                return rooms[code];
            } catch (e) {
                console.error('Failed to get room data:', e);
                return null;
            }
        }

        function deleteRoomData(code) {
            try {
                const rooms = JSON.parse(localStorage.getItem(CONFIG.LOCAL_STORAGE_KEY) || '{}');
                delete rooms[code];
                localStorage.setItem(CONFIG.LOCAL_STORAGE_KEY, JSON.stringify(rooms));
            } catch (e) {
                console.error('Failed to delete room data:', e);
            }
        }

        // ======================
        // GAME INITIALIZATION
        // ======================
        function loadGameAssets() {
            showLoadingScreen(true);
            updateLoadingProgress(0, 'Initializing game engine...');
            
            // First load basic game engine
            setTimeout(() => {
                updateLoadingProgress(30, 'Setting up game world...');
                
                // Initialize Three.js
                initThreeJS();
                
                // Load actual assets or create placeholders
                loadActualAssets();
            }, 500);
        }

        function loadActualAssets() {
            updateLoadingProgress(50, 'Loading game models...');
            
            // Create or load models
            setTimeout(() => {
                // Create map
                createMap();
                
                // Create players
                createPlayers();
                
                // Create enemies
                createEnemies();
                
                // Create extraction zone
                createExtractionZone();
                
                updateLoadingProgress(80, 'Setting up game systems...');
                
                // Initialize game systems
                initMissions();
                setupGameControls();
                startExtractionTimer();
                
                updateLoadingProgress(100, 'Game ready!');
                
                setTimeout(() => {
                    showLoadingScreen(false);
                    startGameLoop();
                    startGameSimulation();
                    
                    showNotification('Game Started!', 'WASD to move, Mouse to look, 1-4 for missions', 5000);
                }, 500);
            }, 1000);
        }

        function initThreeJS() {
            console.log('Initializing Three.js...');
            
            // Create scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x050510, 10, 200);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            
            // Get canvas element
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) {
                console.error('Canvas element not found!');
                return;
            }
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true,
                alpha: false,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 30, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);
            
            // Add hemisphere light for better ambient
            const hemisphereLight = new THREE.HemisphereLight(0x4361ee, 0x0c0c1d, 0.3);
            scene.add(hemisphereLight);
            
            // Skybox
            const skyboxGeometry = new THREE.BoxGeometry(1000, 1000, 1000);
            const skyboxMaterial = new THREE.MeshBasicMaterial({
                color: 0x0c0c1d,
                side: THREE.BackSide
            });
            const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
            scene.add(skybox);
            
            console.log('Three.js initialized successfully');
        }

        function createMap() {
            // Create ground
            const groundGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);
            
            // Create terrain with height variations
            const vertices = groundGeometry.attributes.position;
            for (let i = 0; i < vertices.count; i++) {
                const x = vertices.getX(i);
                const y = vertices.getY(i);
                const z = vertices.getZ(i);
                
                // Add some height variation
                const height = Math.sin(x * 0.05) * Math.cos(z * 0.05) * 3 +
                              Math.sin(x * 0.1) * Math.cos(z * 0.1) * 1.5;
                vertices.setZ(i, height);
            }
            
            groundGeometry.computeVertexNormals();
            
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2a4a2a,
                roughness: 0.8,
                metalness: 0.2
            });
            
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            mapObject = ground;
            
            // Create buildings and structures
            createBuildings();
        }

        function createBuildings() {
            const buildingTypes = [
                { geometry: new THREE.BoxGeometry(8, 12, 8), color: 0x3a3a6a, name: 'Server Room' },
                { geometry: new THREE.CylinderGeometry(4, 4, 10, 6), color: 0x5a3a3a, name: 'Intel Building' },
                { geometry: new THREE.ConeGeometry(5, 8, 8), color: 0x3a5a3a, name: 'Communication Tower' }
            ];
            
            // Create random buildings
            for (let i = 0; i < 15; i++) {
                const typeIndex = Math.floor(Math.random() * buildingTypes.length);
                const type = buildingTypes[typeIndex];
                const building = new THREE.Mesh(type.geometry, new THREE.MeshStandardMaterial({ 
                    color: type.color,
                    roughness: 0.7
                }));
                
                const angle = (i / 15) * Math.PI * 2;
                const radius = 30 + Math.random() * 40;
                building.position.set(
                    Math.cos(angle) * radius,
                    type.geometry.parameters.height / 2,
                    Math.sin(angle) * radius
                );
                
                building.castShadow = true;
                building.receiveShadow = true;
                building.userData = { type: 'building', name: type.name };
                scene.add(building);
                
                // Add windows or details
                if (Math.random() > 0.5) {
                    const windowGeometry = new THREE.BoxGeometry(1, 2, 0.2);
                    const windowMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xffffaa,
                        emissive: 0xffff00,
                        emissiveIntensity: 0.3
                    });
                    
                    for (let w = 0; w < 4; w++) {
                        const window = new THREE.Mesh(windowGeometry, windowMaterial);
                        window.position.set(
                            building.position.x + (Math.random() - 0.5) * 4,
                            building.position.y - 2 + w * 3,
                            building.position.z + 4.1
                        );
                        scene.add(window);
                    }
                }
            }
            
            // Server room (mission objective 1)
            const serverRoom = new THREE.Mesh(
                new THREE.BoxGeometry(15, 8, 15),
                new THREE.MeshStandardMaterial({ 
                    color: 0x1a6a3a,
                    emissive: 0x0a3a1a,
                    emissiveIntensity: 0.3
                })
            );
            serverRoom.position.set(-40, 4, 30);
            serverRoom.castShadow = true;
            serverRoom.receiveShadow = true;
            serverRoom.userData = { type: 'mission', mission: 'serverRoom' };
            scene.add(serverRoom);
            
            // Intel data center (mission objective 2)
            const intelBuilding = new THREE.Mesh(
                new THREE.CylinderGeometry(6, 6, 12, 8),
                new THREE.MeshStandardMaterial({ 
                    color: 0x6a3a1a,
                    emissive: 0x3a1a0a,
                    emissiveIntensity: 0.3
                })
            );
            intelBuilding.position.set(40, 6, -30);
            intelBuilding.castShadow = true;
            intelBuilding.userData = { type: 'mission', mission: 'intel' };
            scene.add(intelBuilding);
            
            // Add antenna
            const antenna = new THREE.Mesh(
                new THREE.ConeGeometry(0.5, 4, 4),
                new THREE.MeshStandardMaterial({ color: 0xaaaaaa })
            );
            antenna.position.set(40, 12, -30);
            scene.add(antenna);
        }

        function createExtractionZone() {
            const extractionGeometry = new THREE.CylinderGeometry(8, 8, 0.2, 32);
            const extractionMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4ade80,
                emissive: 0x4ade80,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.6
            });
            
            extractionZone = new THREE.Mesh(extractionGeometry, extractionMaterial);
            extractionZone.position.set(0, 0.1, 0);
            extractionZone.userData = { type: 'extraction' };
            scene.add(extractionZone);
            
            extractionZone.userData.pulseSpeed = 0.02;
            extractionZone.userData.pulseDirection = 1;
            extractionZone.userData.originalOpacity = 0.6;
        }

        function createPlayers() {
            const playerColors = [0x4361ee, 0xf72585, 0x4ade80, 0xf59e0b];
            
            // Create current player
            const playerGeometry = new THREE.CapsuleGeometry ? new THREE.CapsuleGeometry(0.5, 2, 4, 8) : new THREE.CylinderGeometry(0.5, 0.5, 2, 8);
            const playerMaterial = new THREE.MeshStandardMaterial({ 
                color: playerColors[0],
                emissive: playerColors[0],
                emissiveIntensity: 0.2,
                roughness: 0.5,
                metalness: 0.5
            });
            
            const playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
            playerMesh.position.set(0, 1, 0);
            playerMesh.castShadow = true;
            scene.add(playerMesh);
            
            playerObjects[gameState.playerId] = {
                mesh: playerMesh,
                name: gameState.playerName,
                health: 100,
                maxHealth: 100,
                position: { x: 0, y: 1, z: 0 },
                rotation: { x: 0, y: 0, z: 0 },
                velocity: new THREE.Vector3(),
                speed: CONFIG.PLAYER_SPEED,
                isMoving: false,
                jumping: false,
                onGround: true
            };
            
            // Update UI
            document.getElementById('uiPlayerName').textContent = gameState.playerName;
            document.getElementById('uiHealth').textContent = '100';
            
            // Create other players
            const otherPlayers = Object.values(gameState.players).filter(p => p.id !== gameState.playerId);
            otherPlayers.forEach((player, index) => {
                const material = new THREE.MeshStandardMaterial({ 
                    color: playerColors[(index + 1) % playerColors.length],
                    emissive: playerColors[(index + 1) % playerColors.length],
                    emissiveIntensity: 0.2
                });
                
                const mesh = new THREE.Mesh(playerGeometry, material);
                
                // Position other players around the map
                const positions = [
                    { x: 20, z: 10 },
                    { x: -20, z: 10 },
                    { x: 10, z: -20 }
                ];
                const pos = positions[index] || { x: 0, z: 0 };
                
                mesh.position.set(pos.x, 1, pos.z);
                mesh.castShadow = true;
                scene.add(mesh);
                
                playerObjects[player.id] = {
                    mesh: mesh,
                    name: player.name,
                    health: 100,
                    maxHealth: 100,
                    position: { x: pos.x, y: 1, z: pos.z },
                    rotation: { x: 0, y: 0, z: 0 },
                    velocity: new THREE.Vector3(),
                    speed: CONFIG.PLAYER_SPEED,
                    isMoving: false,
                    jumping: false,
                    onGround: true
                };
            });
            
            updateTeamStatus();
        }

        function createEnemies() {
            const enemyGeometry = new THREE.ConeGeometry(0.6, 2, 8);
            const enemyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xaa3333,
                emissive: 0xaa3333,
                emissiveIntensity: 0.1,
                roughness: 0.7
            });
            
            enemyObjects = [];
            
            for (let i = 0; i < 12; i++) {
                const enemyMesh = new THREE.Mesh(enemyGeometry, enemyMaterial);
                
                // Distribute enemies around objectives
                let x, z;
                if (i < 4) {
                    // Around server room
                    x = -40 + (Math.random() - 0.5) * 20;
                    z = 30 + (Math.random() - 0.5) * 20;
                } else if (i < 8) {
                    // Around intel building
                    x = 40 + (Math.random() - 0.5) * 20;
                    z = -30 + (Math.random() - 0.5) * 20;
                } else {
                    // Random patrol
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 20 + Math.random() * 30;
                    x = Math.cos(angle) * radius;
                    z = Math.sin(angle) * radius;
                }
                
                enemyMesh.position.set(x, 1, z);
                enemyMesh.castShadow = true;
                enemyMesh.userData = { type: 'enemy', health: 100, alive: true };
                scene.add(enemyMesh);
                
                enemyObjects.push({
                    mesh: enemyMesh,
                    health: 100,
                    maxHealth: 100,
                    position: { x, y: 1, z },
                    rotation: 0,
                    alive: true,
                    patrolAngle: Math.random() * Math.PI * 2,
                    patrolSpeed: 0.5 + Math.random(),
                    detectionRange: 15,
                    attackRange: 5,
                    state: 'patrol'
                });
            }
        }

        function setupGameControls() {
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                if (key in gameState.keys) {
                    gameState.keys[key] = true;
                }
                
                // Mission simulation controls
                if (!gameState.gameStarted) return;
                
                switch(key) {
                    case '1':
                        if (window.checkEnemyKill) window.checkEnemyKill();
                        break;
                    case '2':
                        if (window.secureServerRoom) window.secureServerRoom();
                        break;
                    case '3':
                        if (window.downloadIntel) window.downloadIntel();
                        break;
                    case '4':
                        if (gameState.extractionAvailable && window.completeExtraction) {
                            window.completeExtraction();
                        }
                        break;
                    case 'escape':
                        togglePause();
                        break;
                }
            });
            
            document.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                if (key in gameState.keys) {
                    gameState.keys[key] = false;
                }
            });
            
            // Mouse controls
            document.addEventListener('mousemove', (e) => {
                if (!gameState.gameStarted || gameState.gamePaused) return;
                
                gameState.mouse.x = e.movementX || 0;
                gameState.mouse.y = e.movementY || 0;
                
                // Update camera rotation
                if (camera && playerObjects[gameState.playerId]) {
                    const player = playerObjects[gameState.playerId];
                    player.rotation.y -= gameState.mouse.x * gameState.mouse.sensitivity;
                    player.rotation.x -= gameState.mouse.y * gameState.mouse.sensitivity;
                    
                    // Clamp vertical rotation
                    player.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, player.rotation.x));
                }
            });
            
            // Lock pointer when clicking on game
            const canvas = document.getElementById('gameCanvas');
            canvas.addEventListener('click', () => {
                if (gameState.gameStarted && !gameState.gamePaused) {
                    canvas.requestPointerLock();
                }
            });
            
            // Handle pointer lock change
            document.addEventListener('pointerlockchange', () => {
                gameState.pointerLocked = document.pointerLockElement === canvas;
            });
        }

        function updatePlayerMovement(deltaTime) {
            if (!playerObjects[gameState.playerId] || gameState.gamePaused) return;
            
            const player = playerObjects[gameState.playerId];
            const speed = gameState.keys.shift ? CONFIG.PLAYER_RUN_SPEED : CONFIG.PLAYER_SPEED;
            
            // Reset velocity
            player.velocity.set(0, 0, 0);
            
            // Calculate movement direction based on camera rotation
            const forward = new THREE.Vector3();
            const right = new THREE.Vector3();
            
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();
            
            right.crossVectors(camera.up, forward).normalize();
            
            // Apply movement
            if (gameState.keys.w) {
                player.velocity.add(forward.clone().multiplyScalar(speed));
            }
            if (gameState.keys.s) {
                player.velocity.add(forward.clone().multiplyScalar(-speed));
            }
            if (gameState.keys.a) {
                player.velocity.add(right.clone().multiplyScalar(speed));
            }
            if (gameState.keys.d) {
                player.velocity.add(right.clone().multiplyScalar(-speed));
            }
            
            // Jump
            if (gameState.keys.space && player.onGround) {
                player.velocity.y = CONFIG.PLAYER_JUMP_FORCE;
                player.onGround = false;
                player.jumping = true;
            }
            
            // Apply gravity
            if (!player.onGround) {
                player.velocity.y -= CONFIG.GRAVITY * deltaTime;
            }
            
            // Update position
            player.position.x += player.velocity.x * deltaTime;
            player.position.y += player.velocity.y * deltaTime;
            player.position.z += player.velocity.z * deltaTime;
            
            // Ground collision
            if (player.position.y < 1) {
                player.position.y = 1;
                player.velocity.y = 0;
                player.onGround = true;
                player.jumping = false;
            }
            
            // Update mesh position
            player.mesh.position.set(player.position.x, player.position.y, player.position.z);
            
            // Update camera position
            if (camera) {
                // Third-person camera
                const cameraDistance = 10;
                const cameraHeight = 5;
                
                const cameraOffset = new THREE.Vector3(
                    Math.sin(player.rotation.y) * cameraDistance,
                    cameraHeight,
                    Math.cos(player.rotation.y) * cameraDistance
                );
                
                camera.position.set(
                    player.position.x + cameraOffset.x,
                    player.position.y + cameraOffset.y,
                    player.position.z + cameraOffset.z
                );
                
                camera.lookAt(player.position.x, player.position.y + 2, player.position.z);
            }
        }

        function initMissions() {
            // Mission 1: Eliminate enemies
            window.checkEnemyKill = function() {
                if (!gameState.gameStarted) return;
                
                gameState.missions.enemiesKilled++;
                document.getElementById('uiKills').textContent = gameState.missions.enemiesKilled;
                
                const missionElement = document.getElementById('mission1');
                missionElement.querySelector('span').textContent = 
                    `Eliminate 10 enemies (${gameState.missions.enemiesKilled}/10)`;
                
                if (gameState.missions.enemiesKilled >= 10) {
                    missionElement.classList.add('completed');
                    showNotification('Mission Complete!', 'Enemy elimination objective completed!', 5000);
                }
                
                // Update enemy count
                const aliveEnemies = enemyObjects.filter(e => e.alive).length;
                if (aliveEnemies === 0) {
                    showNotification('All Enemies Defeated!', 'Area secured!', 3000);
                }
            };
            
            // Mission 2: Secure server room
            window.secureServerRoom = function() {
                if (!gameState.gameStarted || gameState.missions.serverSecured) return;
                
                gameState.missions.serverSecured = true;
                document.getElementById('mission2').classList.add('completed');
                updateObjectivesCount();
                showNotification('Server Room Secured!', 'Critical data protected', 5000);
            };
            
            // Mission 3: Download intel
            window.downloadIntel = function() {
                if (!gameState.gameStarted || gameState.missions.intelDownloaded) return;
                
                gameState.missions.intelDownloaded = true;
                document.getElementById('mission3').classList.add('completed');
                updateObjectivesCount();
                showNotification('Intel Downloaded!', 'Critical intelligence acquired', 5000);
            };
            
            // Mission 4: Extract
            window.completeExtraction = function() {
                if (!gameState.gameStarted || !gameState.extractionAvailable) return;
                
                // Check if player is near extraction zone
                const player = playerObjects[gameState.playerId];
                const distanceToExtraction = Math.sqrt(
                    Math.pow(player.position.x - extractionZone.position.x, 2) +
                    Math.pow(player.position.z - extractionZone.position.z, 2)
                );
                
                if (distanceToExtraction < 10) {
                    gameState.missions.extractionReady = true;
                    document.getElementById('mission4').classList.add('completed');
                    showNotification('Extraction Complete!', 'Mission accomplished! Well done, team!', 10000);
                    
                    // Game over - victory
                    setTimeout(() => {
                        showNotification('VICTORY', 'All missions completed successfully!', 10000);
                    }, 2000);
                } else {
                    showNotification('Too Far', 'Move closer to the extraction zone!', 3000);
                }
            };
            
            function updateObjectivesCount() {
                const count = (gameState.missions.serverSecured ? 1 : 0) + 
                             (gameState.missions.intelDownloaded ? 1 : 0);
                document.getElementById('uiObjectives').textContent = count;
            }
        }

        function updateTeamStatus() {
            const teamStatus = document.getElementById('teamStatus');
            if (!teamStatus) return;
            
            teamStatus.innerHTML = '';
            
            Object.values(playerObjects).forEach(player => {
                const div = document.createElement('div');
                div.className = 'team-member';
                div.style.marginBottom = '8px';
                div.style.padding = '8px';
                div.style.background = 'rgba(20, 20, 40, 0.5)';
                div.style.borderRadius = '6px';
                div.style.borderLeft = `3px solid ${player.health > 50 ? '#4ade80' : player.health > 20 ? '#f59e0b' : '#ef4444'}`;
                
                div.innerHTML = `
                    <strong style="color: #4cc9f0;">${player.name}</strong><br>
                    <span style="font-size: 0.9rem;">Health: ${player.health}%</span><br>
                    <span style="font-size: 0.8rem; color: ${player.health > 0 ? '#4ade80' : '#ef4444'}">
                        ${player.health > 0 ? 'ACTIVE' : 'DOWN'}
                    </span>
                `;
                
                teamStatus.appendChild(div);
            });
        }

        // ======================
        // GAME LOOP
        // ======================
        function startGameLoop() {
            if (gameState.gameLoopRunning) {
                console.log('Game loop already running');
                return;
            }
            
            gameState.gameLoopRunning = true;
            console.log('Starting game loop...');
            
            function animate() {
                if (!gameState.gameStarted || !renderer || !scene || !camera) {
                    requestAnimationFrame(animate);
                    return;
                }
                
                requestAnimationFrame(animate);
                
                // Calculate delta time
                deltaTime = clock.getDelta();
                gameState.gameTime += deltaTime;
                gameState.frameCount++;
                
                // Update player movement
                updatePlayerMovement(deltaTime);
                
                // Update game systems
                updateExtractionZone();
                updateEnemies();
                updateCamera();
                
                // Render scene
                try {
                    renderer.render(scene, camera);
                } catch (error) {
                    console.error('Error rendering scene:', error);
                    gameState.gameLoopRunning = false;
                }
            }
            
            // Start the animation loop
            animate();
            console.log('Game loop started successfully');
        }

        function updateExtractionZone() {
            if (!extractionZone || !extractionZone.userData) return;
            
            // Pulse effect
            if (gameState.extractionAvailable) {
                extractionZone.material.opacity += extractionZone.userData.pulseSpeed * extractionZone.userData.pulseDirection;
                
                if (extractionZone.material.opacity >= 0.8 || extractionZone.material.opacity <= 0.4) {
                    extractionZone.userData.pulseDirection *= -1;
                }
                
                // Rotate slowly
                extractionZone.rotation.z += 0.002;
            }
        }

        function updateEnemies() {
            enemyObjects.forEach(enemy => {
                if (!enemy.alive) return;
                
                // Simple patrol behavior
                enemy.patrolAngle += enemy.patrolSpeed * deltaTime;
                enemy.mesh.position.x = enemy.position.x + Math.cos(enemy.patrolAngle) * 3;
                enemy.mesh.position.z = enemy.position.z + Math.sin(enemy.patrolAngle) * 3;
                
                // Look at movement direction
                enemy.mesh.rotation.y = enemy.patrolAngle + Math.PI / 2;
                
                // Bob up and down
                enemy.mesh.position.y = enemy.position.y + Math.sin(gameState.gameTime * 2 + enemy.patrolAngle) * 0.1;
                
                // Check distance to player
                const player = playerObjects[gameState.playerId];
                if (player) {
                    const distanceToPlayer = Math.sqrt(
                        Math.pow(enemy.mesh.position.x - player.position.x, 2) +
                        Math.pow(enemy.mesh.position.z - player.position.z, 2)
                    );
                    
                    if (distanceToPlayer < enemy.detectionRange) {
                        // Enemy detected player
                        enemy.state = 'chase';
                        
                        // Move toward player
                        const dx = player.position.x - enemy.mesh.position.x;
                        const dz = player.position.z - enemy.mesh.position.z;
                        const angleToPlayer = Math.atan2(dz, dx);
                        
                        enemy.mesh.position.x += Math.cos(angleToPlayer) * enemy.patrolSpeed * deltaTime * 2;
                        enemy.mesh.position.z += Math.sin(angleToPlayer) * enemy.patrolSpeed * deltaTime * 2;
                        enemy.mesh.rotation.y = angleToPlayer - Math.PI / 2;
                    } else {
                        enemy.state = 'patrol';
                    }
                }
            });
        }

        function updateCamera() {
            // Camera is updated in updatePlayerMovement
        }

        function startExtractionTimer() {
            const timerElement = document.getElementById('extractionTimer');
            if (!timerElement) return;
            
            let remainingTime = gameState.extractionTimer;
            
            const timerInterval = setInterval(() => {
                if (!gameState.gameStarted) {
                    clearInterval(timerInterval);
                    return;
                }
                
                remainingTime--;
                
                const minutes = Math.floor(remainingTime / 60);
                const seconds = remainingTime % 60;
                
                timerElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                // Visual feedback
                if (remainingTime <= 30) {
                    timerElement.classList.add('pulse');
                }
                
                if (remainingTime <= 10) {
                    timerElement.style.color = '#ef4444';
                }
                
                if (remainingTime <= 0) {
                    clearInterval(timerInterval);
                    gameState.extractionAvailable = true;
                    if (extractionZone && extractionZone.userData) {
                        extractionZone.userData.active = true;
                    }
                    timerElement.textContent = 'EXTRACTION READY';
                    showNotification('Extraction Available!', 'Meet at the extraction zone!', 10000);
                    document.getElementById('mission4').classList.remove('hidden');
                }
            }, 1000);
        }

        function startGameSimulation() {
            // Simulate random events
            setInterval(() => {
                if (!gameState.gameStarted) return;
                
                // Random enemy kills (for demo)
                if (Math.random() > 0.8 && gameState.missions.enemiesKilled < 10) {
                    window.checkEnemyKill();
                }
                
                // Random damage to players
                Object.values(playerObjects).forEach(player => {
                    if (Math.random() > 0.9 && player.health > 0) {
                        const damage = Math.floor(Math.random() * 15) + 5;
                        player.health = Math.max(0, player.health - damage);
                        
                        if (player.id === gameState.playerId) {
                            document.getElementById('uiHealth').textContent = player.health;
                            updateTeamStatus();
                            
                            if (player.health <= 30 && player.health > 0) {
                                showNotification('Low Health!', 'Find cover and recover!', 3000);
                            }
                            
                            if (player.health <= 0) {
                                showNotification('You are down!', 'Wait for teammate to revive you', 5000);
                            }
                        }
                    }
                });
            }, 3000);
            
            // Auto-complete missions after time (for demo)
            setTimeout(() => {
                if (gameState.gameStarted && !gameState.missions.serverSecured) {
                    window.secureServerRoom();
                }
            }, 10000);
            
            setTimeout(() => {
                if (gameState.gameStarted && !gameState.missions.intelDownloaded) {
                    window.downloadIntel();
                }
            }, 20000);
        }

        function togglePause() {
            gameState.gamePaused = !gameState.gamePaused;
            showNotification(
                gameState.gamePaused ? 'Game Paused' : 'Game Resumed',
                gameState.gamePaused ? 'Press ESC to resume' : 'Continue your mission',
                3000
            );
        }

        // ======================
        // UTILITY FUNCTIONS
        // ======================
        function showLoadingScreen(show) {
            const loadingScreen = document.getElementById('loadingScreen');
            if (show) {
                loadingScreen.classList.remove('hidden');
            } else {
                loadingScreen.classList.add('hidden');
            }
        }

        function updateLoadingProgress(percent, message) {
            const loadingBar = document.getElementById('loadingBar');
            const loadingFile = document.getElementById('loadingFile');
            
            if (loadingBar) loadingBar.style.width = percent + '%';
            if (loadingFile) loadingFile.textContent = message;
        }

        function showNotification(title, message, duration = 5000) {
            const notificationArea = document.getElementById('notificationArea');
            if (!notificationArea) return;
            
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.innerHTML = `
                <div class="notification-title">${title}</div>
                <div class="notification-message">${message}</div>
            `;
            
            notificationArea.appendChild(notification);
            
            // Animate in
            setTimeout(() => notification.classList.add('show'), 10);
            
            // Remove after duration
            if (duration > 0) {
                setTimeout(() => {
                    notification.classList.remove('show');
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 400);
                }, duration);
            }
        }

        function onWindowResize() {
            if (!camera || !renderer) return;
            
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Update pixel ratio for performance
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        }

        function handleBeforeUnload(e) {
            if (gameState.gameStarted || gameState.roomCode) {
                e.preventDefault();
                e.returnValue = 'Are you sure you want to leave? Your game progress will be lost.';
                
                // Clean up room if leaving
                if (gameState.roomCode && gameState.isHost) {
                    deleteRoomData(gameState.roomCode);
                }
            }
        }
    </script>
</body>
</html>
