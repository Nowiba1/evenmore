<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéÆ Cube Defenders - WiFi Co-op Game</title>
    <!-- Include Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #f8fafc;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            width: 100%;
            max-width: 1200px;
        }
        
        h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #60a5fa, #8b5cf6);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 4px 20px rgba(96, 165, 250, 0.3);
        }
        
        .tagline {
            font-size: 1.3rem;
            opacity: 0.9;
            margin-bottom: 25px;
            color: #cbd5e1;
        }
        
        .container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            width: 100%;
            max-width: 1400px;
        }
        
        .left-panel {
            flex: 0 0 400px;
            display: flex;
            flex-direction: column;
            gap: 25px;
        }
        
        .game-section {
            flex: 1;
            min-width: 300px;
            height: 600px;
            background: rgba(15, 23, 42, 0.8);
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(96, 165, 250, 0.3);
            position: relative;
        }
        
        .panel {
            background: rgba(30, 41, 59, 0.9);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(96, 165, 250, 0.2);
            backdrop-filter: blur(10px);
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background: #0f172a;
        }
        
        .panel h2 {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: #60a5fa;
            display: flex;
            align-items: center;
            gap: 12px;
            border-bottom: 2px solid rgba(96, 165, 250, 0.3);
            padding-bottom: 10px;
        }
        
        .room-code-container {
            text-align: center;
            margin: 20px 0;
            padding: 20px;
            background: rgba(15, 23, 42, 0.7);
            border-radius: 10px;
            border: 2px solid rgba(96, 165, 250, 0.3);
        }
        
        .room-code {
            font-size: 4rem;
            font-weight: bold;
            letter-spacing: 10px;
            color: #10b981;
            text-shadow: 0 0 20px rgba(16, 185, 129, 0.5);
            margin: 15px 0;
            font-family: monospace;
            background: rgba(15, 23, 42, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid rgba(16, 185, 129, 0.4);
        }
        
        .code-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
        }
        
        .btn {
            background: linear-gradient(90deg, #3b82f6, #6366f1);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            box-shadow: 0 5px 20px rgba(59, 130, 246, 0.4);
            flex: 1;
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.6);
        }
        
        .btn:active {
            transform: translateY(1px);
        }
        
        .btn-copy {
            background: linear-gradient(90deg, #10b981, #059669);
            box-shadow: 0 5px 20px rgba(16, 185, 129, 0.4);
        }
        
        .btn-copy:hover {
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.6);
        }
        
        .btn-start {
            background: linear-gradient(90deg, #f59e0b, #d97706);
            box-shadow: 0 5px 20px rgba(245, 158, 11, 0.4);
        }
        
        .btn-start:hover {
            box-shadow: 0 8px 25px rgba(245, 158, 11, 0.6);
        }
        
        .btn-disabled {
            background: #475569;
            cursor: not-allowed;
            opacity: 0.7;
            box-shadow: none;
        }
        
        .btn-disabled:hover {
            transform: none;
            box-shadow: none;
        }
        
        .player-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .player-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px;
            background: rgba(15, 23, 42, 0.7);
            border-radius: 10px;
            border: 2px solid;
            transition: all 0.3s ease;
        }
        
        .player-item.ready {
            border-color: #10b981;
            background: rgba(16, 185, 129, 0.1);
        }
        
        .player-info {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
        }
        
        .player-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2rem;
        }
        
        .player-details {
            flex: 1;
        }
        
        .player-name {
            font-weight: 600;
            font-size: 1.2rem;
            margin-bottom: 5px;
        }
        
        .player-role {
            font-size: 0.9rem;
            opacity: 0.8;
            color: #60a5fa;
        }
        
        .player-ready {
            color: #10b981;
            font-weight: bold;
            padding: 5px 15px;
            background: rgba(16, 185, 129, 0.2);
            border-radius: 20px;
            font-size: 0.9rem;
        }
        
        .player-waiting {
            color: #f59e0b;
            font-weight: bold;
            padding: 5px 15px;
            background: rgba(245, 158, 11, 0.2);
            border-radius: 20px;
            font-size: 0.9rem;
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 15px;
        }
        
        .control-key {
            background: rgba(15, 23, 42, 0.7);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(96, 165, 250, 0.2);
            transition: all 0.3s ease;
        }
        
        .control-key:hover {
            transform: translateY(-3px);
            border-color: #60a5fa;
            box-shadow: 0 5px 15px rgba(96, 165, 250, 0.3);
        }
        
        .key {
            display: inline-block;
            background: rgba(30, 41, 59, 0.9);
            padding: 8px 15px;
            border-radius: 8px;
            font-family: monospace;
            font-weight: bold;
            margin-right: 10px;
            border: 2px solid #475569;
            color: #60a5fa;
        }
        
        .game-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 20px;
        }
        
        .stat {
            text-align: center;
            padding: 15px;
            background: rgba(15, 23, 42, 0.7);
            border-radius: 10px;
            border: 1px solid rgba(96, 165, 250, 0.2);
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #60a5fa;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
            color: #cbd5e1;
        }
        
        .status-message {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: 600;
            transition: all 0.3s ease;
            border: 2px solid;
        }
        
        .status-connecting {
            background: rgba(245, 158, 11, 0.1);
            color: #f59e0b;
            border-color: rgba(245, 158, 11, 0.3);
        }
        
        .status-connected {
            background: rgba(16, 185, 129, 0.1);
            color: #10b981;
            border-color: rgba(16, 185, 129, 0.3);
        }
        
        .status-error {
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
            border-color: rgba(239, 68, 68, 0.3);
        }
        
        .instructions {
            line-height: 1.7;
            font-size: 1rem;
            color: #cbd5e1;
        }
        
        .instructions ul {
            padding-left: 25px;
            margin-top: 15px;
        }
        
        .instructions li {
            margin-bottom: 12px;
            padding-left: 5px;
        }
        
        .instructions strong {
            color: #60a5fa;
        }
        
        .room-input {
            width: 100%;
            padding: 15px;
            font-size: 1.2rem;
            text-align: center;
            letter-spacing: 10px;
            background: rgba(15, 23, 42, 0.9);
            border: 2px solid #475569;
            border-radius: 10px;
            color: #f8fafc;
            font-family: monospace;
            font-weight: bold;
            margin-bottom: 20px;
        }
        
        .room-input:focus {
            outline: none;
            border-color: #60a5fa;
            box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.3);
        }
        
        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 23, 42, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 30px;
            z-index: 100;
            border-radius: 20px;
        }
        
        .game-overlay h2 {
            font-size: 3rem;
            color: #60a5fa;
            text-shadow: 0 0 30px rgba(96, 165, 250, 0.5);
        }
        
        .game-overlay p {
            font-size: 1.5rem;
            color: #cbd5e1;
            text-align: center;
            max-width: 80%;
        }
        
        .hidden {
            display: none !important;
        }
        
        .footer {
            margin-top: 40px;
            text-align: center;
            opacity: 0.7;
            font-size: 0.9rem;
            max-width: 1200px;
            padding: 20px;
            color: #94a3b8;
        }
        
        @media (max-width: 1100px) {
            .container {
                flex-direction: column;
                align-items: center;
            }
            
            .left-panel {
                width: 100%;
                max-width: 800px;
            }
            
            .game-section {
                height: 500px;
            }
        }
        
        @media (max-width: 600px) {
            h1 {
                font-size: 2.2rem;
            }
            
            .room-code {
                font-size: 3rem;
                letter-spacing: 5px;
                padding: 10px;
            }
            
            .game-section {
                height: 400px;
            }
            
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            .game-stats {
                grid-template-columns: 1fr;
                gap: 10px;
            }
        }
        
        .player-stats {
            display: flex;
            gap: 10px;
        }
        
        .player-stat {
            background: rgba(15, 23, 42, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9rem;
            border: 1px solid rgba(96, 165, 250, 0.2);
        }
        
        .health-bar {
            width: 100%;
            height: 10px;
            background: rgba(239, 68, 68, 0.2);
            border-radius: 5px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #059669);
            transition: width 0.3s ease;
        }
        
        .upgrade-item {
            background: rgba(15, 23, 42, 0.7);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            border: 1px solid rgba(96, 165, 250, 0.2);
        }
        
        .upgrade-item h4 {
            color: #f59e0b;
            margin-bottom: 5px;
        }
        
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0f172a;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .loader {
            width: 50px;
            height: 50px;
            border: 5px solid #3b82f6;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        <div class="loader"></div>
    </div>
    
    <div class="header">
        <h1>üéÆ Cube Defenders</h1>
        <p class="tagline">3D Co-op Tower Defense - Play with friends on the same WiFi!</p>
    </div>
    
    <div class="container">
        <div class="left-panel">
            <div class="panel">
                <h2>üïπÔ∏è Game Rooms</h2>
                <div id="statusMessage" class="status-message status-connecting">
                    üîç Looking for rooms on your WiFi...
                </div>
                
                <div id="hostSection" class="hidden">
                    <div class="room-code-container">
                        <h3>Room Code</h3>
                        <div class="room-code" id="roomCode">0000</div>
                        <div class="code-actions">
                            <button id="copyBtn" class="btn btn-copy">üìã Copy Code</button>
                            <button id="newCodeBtn" class="btn">üîÑ New Code</button>
                        </div>
                        <p style="margin-top: 15px; color: #94a3b8; font-size: 0.9rem;">
                            Share this code with your friend on the same WiFi
                        </p>
                    </div>
                </div>
                
                <div id="joinSection">
                    <h3>Join Room</h3>
                    <input type="text" id="roomInput" class="room-input" maxlength="4" placeholder="Enter 4-digit code" pattern="[0-9]{4}">
                    <div class="code-actions">
                        <button id="joinBtn" class="btn">üéÆ Join Room</button>
                        <button id="createBtn" class="btn">‚ú® Create Room</button>
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <h2>üë• Players</h2>
                <div class="player-list" id="playerList">
                    <!-- Players will be added here dynamically -->
                </div>
                <button id="readyBtn" class="btn btn-start btn-disabled">‚è≥ Waiting for players...</button>
            </div>
            
            <div class="panel">
                <h2>üìä Game Stats</h2>
                <div class="game-stats">
                    <div class="stat">
                        <div class="stat-value" id="waveCount">1</div>
                        <div class="stat-label">Current Wave</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="enemiesLeft">0</div>
                        <div class="stat-label">Enemies</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="timeAlive">0</div>
                        <div class="stat-label">Seconds</div>
                    </div>
                </div>
                <div class="health-bar">
                    <div class="health-fill" id="cubeHealthBar" style="width: 100%"></div>
                </div>
                <div style="text-align: center; margin-top: 10px; font-size: 0.9rem; color: #94a3b8;">
                    Cube Health: <span id="cubeHealthText">100</span>/100
                </div>
            </div>
        </div>
        
        <div class="game-section">
            <canvas id="gameCanvas"></canvas>
            <div id="waitingOverlay" class="game-overlay">
                <h2>üéÆ Cube Defenders</h2>
                <p>Create a room or join with a 4-digit code to start playing!</p>
                <p style="font-size: 1rem; color: #94a3b8;">Make sure all players are on the same WiFi network</p>
            </div>
        </div>
        
        <div class="left-panel">
            <div class="panel">
                <h2>üéÆ Controls</h2>
                <div class="controls-grid">
                    <div class="control-key">
                        <span class="key">W</span> / <span class="key">S</span><br>
                        Move Forward/Back
                    </div>
                    <div class="control-key">
                        <span class="key">A</span> / <span class="key">D</span><br>
                        Move Left/Right
                    </div>
                    <div class="control-key">
                        <span class="key">SPACE</span><br>
                        Place Block (Builder)
                    </div>
                    <div class="control-key">
                        <span class="key">MOUSE</span><br>
                        Look Around
                    </div>
                    <div class="control-key">
                        <span class="key">E</span><br>
                        Shoot (Shooter)
                    </div>
                    <div class="control-key">
                        <span class="key">R</span><br>
                        Special Ability
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <h2>üéØ Game Rules</h2>
                <div class="instructions">
                    <p><strong>Objective:</strong> Defend the central cube from enemy waves!</p>
                    <ul>
                        <li><strong>Builder (Player 1):</strong> Place defensive blocks with SPACE</li>
                        <li><strong>Shooter (Player 2):</strong> Shoot enemies with E key</li>
                        <li><strong>Work together</strong> to survive as many waves as possible</li>
                        <li>Each wave gets harder with more enemies</li>
                        <li>Upgrade your abilities between waves</li>
                    </ul>
                </div>
            </div>
            
            <div class="panel">
                <h2>üîß Upgrades</h2>
                <div id="upgradesContainer">
                    <p style="color: #94a3b8; text-align: center;">Upgrades unlock between waves</p>
                </div>
            </div>
        </div>
    </div>
    
    <div class="footer">
        <p>Cube Defenders - A frontend-only 3D co-op game using Three.js and WebRTC Data Channels</p>
        <p>Works on any device with a modern browser - Make sure all players are on the same WiFi!</p>
    </div>

    <script>
        // ==================== GAME STATE ====================
        const gameState = {
            roomCode: null,
            players: {},
            playerId: null,
            isHost: false,
            gameStarted: false,
            wave: 1,
            enemies: [],
            blocks: [],
            projectiles: [],
            timeAlive: 0,
            cubeHealth: 100,
            score: 0,
            upgrades: {
                blockHealth: 1,
                fireRate: 1,
                damage: 1
            }
        };
        
        // ==================== THREE.JS VARIABLES ====================
        let scene, camera, renderer, canvas;
        let playerMesh, enemyMeshes = [], blockMeshes = [], projectileMeshes = [], centralCube;
        let keys = {};
        let mouse = { x: 0, y: 0 };
        
        // ==================== NETWORKING SYSTEM ====================
        class GameNetwork {
            constructor() {
                this.rooms = {};
                this.localId = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                this.currentRoom = null;
                this.isHost = false;
                
                // Create BroadcastChannel for local communication
                try {
                    this.broadcastChannel = new BroadcastChannel('cube_defenders');
                    this.setupBroadcastChannel();
                    console.log("BroadcastChannel initialized");
                } catch (e) {
                    console.warn("BroadcastChannel not supported, using localStorage fallback");
                    this.broadcastChannel = null;
                    this.setupLocalStorageFallback();
                }
            }
            
            setupBroadcastChannel() {
                this.broadcastChannel.onmessage = (event) => {
                    this.handleMessage(event.data);
                };
            }
            
            setupLocalStorageFallback() {
                // Fallback using localStorage and storage events
                window.addEventListener('storage', (event) => {
                    if (event.key === 'cube_defenders_msg') {
                        const data = JSON.parse(event.newValue);
                        if (data.roomCode === this.currentRoom) {
                            this.handleMessage(data);
                        }
                    }
                });
                
                // Also poll for changes
                setInterval(() => {
                    const msg = localStorage.getItem('cube_defenders_msg');
                    if (msg) {
                        const data = JSON.parse(msg);
                        if (data.roomCode === this.currentRoom && data.timestamp > (Date.now() - 1000)) {
                            this.handleMessage(data);
                        }
                    }
                }, 100);
            }
            
            handleMessage(data) {
                switch(data.type) {
                    case 'roomCreated':
                        if (!this.isHost && data.roomCode === this.currentRoom) {
                            this.connectToRoom(data);
                        }
                        break;
                        
                    case 'joinRequest':
                        if (this.isHost && data.roomCode === this.currentRoom) {
                            this.acceptJoinRequest(data);
                        }
                        break;
                        
                    case 'joinAccepted':
                        if (!this.isHost && data.roomCode === this.currentRoom) {
                            this.handleJoinAccepted(data);
                        }
                        break;
                        
                    case 'gameState':
                        if (data.roomCode === this.currentRoom) {
                            this.handleGameState(data.state);
                        }
                        break;
                        
                    case 'playerReady':
                        if (data.roomCode === this.currentRoom) {
                            this.handlePlayerReady(data.playerId);
                        }
                        break;
                        
                    case 'playerAction':
                        if (data.roomCode === this.currentRoom && data.playerId !== this.localId) {
                            this.handlePlayerAction(data);
                        }
                        break;
                        
                    case 'roomClosed':
                        if (data.roomCode === this.currentRoom) {
                            this.handleRoomClosed();
                        }
                        break;
                }
            }
            
            sendMessage(data) {
                data.roomCode = this.currentRoom;
                data.timestamp = Date.now();
                
                if (this.broadcastChannel) {
                    this.broadcastChannel.postMessage(data);
                } else {
                    // localStorage fallback
                    localStorage.setItem('cube_defenders_msg', JSON.stringify(data));
                    // Remove old message after 1 second
                    setTimeout(() => {
                        localStorage.removeItem('cube_defenders_msg');
                    }, 1000);
                }
            }
            
            createRoom() {
                const roomCode = this.generateRoomCode();
                this.currentRoom = roomCode;
                this.isHost = true;
                gameState.roomCode = roomCode;
                gameState.playerId = this.localId;
                gameState.isHost = true;
                
                // Clear any existing players
                gameState.players = {};
                
                // Add host to players
                gameState.players[this.localId] = {
                    id: this.localId,
                    name: 'Player 1',
                    role: 'builder',
                    color: '#3b82f6',
                    ready: false,
                    position: { x: 5, y: 1, z: 5 },
                    stats: { kills: 0, blocks: 0, damage: 0 }
                };
                
                // Broadcast room creation
                this.sendMessage({
                    type: 'roomCreated',
                    roomCode: roomCode,
                    hostId: this.localId
                });
                
                this.updatePlayerList();
                return roomCode;
            }
            
            joinRoom(roomCode) {
                if (!this.validateRoomCode(roomCode)) {
                    showError('Invalid room code! Must be 4 digits.');
                    return false;
                }
                
                this.currentRoom = roomCode;
                this.isHost = false;
                gameState.roomCode = roomCode;
                gameState.playerId = this.localId;
                gameState.isHost = false;
                
                // Clear any existing players
                gameState.players = {};
                
                // Add player to game state
                gameState.players[this.localId] = {
                    id: this.localId,
                    name: 'Player 2',
                    role: 'shooter',
                    color: '#8b5cf6',
                    ready: false,
                    position: { x: -5, y: 1, z: -5 },
                    stats: { kills: 0, blocks: 0, damage: 0 }
                };
                
                // Request to join
                this.sendMessage({
                    type: 'joinRequest',
                    roomCode: roomCode,
                    playerId: this.localId,
                    playerInfo: gameState.players[this.localId]
                });
                
                this.updatePlayerList();
                return true;
            }
            
            connectToRoom(data) {
                // Player connecting to existing room
                showMessage(`Connecting to room ${data.roomCode}...`);
            }
            
            acceptJoinRequest(data) {
                // Add player to game state
                gameState.players[data.playerId] = data.playerInfo;
                
                // Send current game state to new player
                this.sendMessage({
                    type: 'joinAccepted',
                    roomCode: this.currentRoom,
                    hostId: this.localId,
                    gameState: gameState
                });
                
                this.updatePlayerList();
                this.syncGameState();
                showMessage(`${data.playerInfo.name} joined the room!`);
            }
            
            handleJoinAccepted(data) {
                // Update with host's game state
                Object.assign(gameState, data.gameState);
                updateGameUI();
                showMessage(`Joined room ${data.roomCode}! Waiting for host to start...`);
            }
            
            syncGameState() {
                this.sendMessage({
                    type: 'gameState',
                    state: gameState
                });
            }
            
            sendPlayerAction(action, data) {
                this.sendMessage({
                    type: 'playerAction',
                    playerId: this.localId,
                    action: action,
                    data: data
                });
            }
            
            sendPlayerReady() {
                if (gameState.players[this.localId]) {
                    gameState.players[this.localId].ready = true;
                    this.sendMessage({
                        type: 'playerReady',
                        playerId: this.localId
                    });
                    this.updatePlayerList();
                    this.syncGameState();
                }
            }
            
            handleGameState(state) {
                // Merge received state (except local player position)
                const localPlayer = gameState.players[gameState.playerId];
                Object.assign(gameState, state);
                if (localPlayer) {
                    gameState.players[gameState.playerId] = localPlayer;
                }
                updateGameUI();
            }
            
            handlePlayerReady(playerId) {
                if (gameState.players[playerId]) {
                    gameState.players[playerId].ready = true;
                    this.updatePlayerList();
                    
                    // Check if all players are ready
                    const players = Object.values(gameState.players);
                    const allReady = players.length >= 2 && players.every(p => p.ready);
                    if (allReady && this.isHost) {
                        startGame();
                    }
                }
            }
            
            handlePlayerAction(data) {
                switch(data.action) {
                    case 'move':
                        if (gameState.players[data.playerId]) {
                            gameState.players[data.playerId].position = data.data;
                        }
                        break;
                        
                    case 'placeBlock':
                        createBlock(data.data.position, data.data.color);
                        break;
                        
                    case 'shoot':
                        createProjectile(data.data.position, data.data.direction);
                        break;
                }
            }
            
            handleRoomClosed() {
                showError('Room was closed by host!');
                resetToLobby();
            }
            
            closeRoom() {
                if (this.isHost) {
                    this.sendMessage({
                        type: 'roomClosed',
                        roomCode: this.currentRoom
                    });
                }
            }
            
            generateRoomCode() {
                return Math.floor(1000 + Math.random() * 9000).toString();
            }
            
            validateRoomCode(code) {
                return /^\d{4}$/.test(code);
            }
            
            updatePlayerList() {
                const playerList = document.getElementById('playerList');
                playerList.innerHTML = '';
                
                Object.values(gameState.players).forEach(player => {
                    const playerItem = document.createElement('div');
                    playerItem.className = `player-item ${player.ready ? 'ready' : ''}`;
                    playerItem.style.borderColor = player.color;
                    
                    playerItem.innerHTML = `
                        <div class="player-info">
                            <div class="player-avatar" style="background: ${player.color}">${player.name.charAt(0)}</div>
                            <div class="player-details">
                                <div class="player-name">${player.name}</div>
                                <div class="player-role">${player.role === 'builder' ? 'üèóÔ∏è Builder' : 'üî´ Shooter'}</div>
                                <div class="player-stats">
                                    <span class="player-stat">üéØ ${player.stats.kills}</span>
                                    <span class="player-stat">üß± ${player.stats.blocks}</span>
                                </div>
                            </div>
                        </div>
                        <div class="${player.ready ? 'player-ready' : 'player-waiting'}">
                            ${player.ready ? '‚úÖ Ready' : '‚è≥ Waiting'}
                        </div>
                    `;
                    
                    playerList.appendChild(playerItem);
                });
                
                // Update ready button
                const readyBtn = document.getElementById('readyBtn');
                if (Object.keys(gameState.players).length >= 1) {
                    readyBtn.disabled = false;
                    readyBtn.className = 'btn btn-start';
                    readyBtn.innerHTML = gameState.players[gameState.playerId]?.ready ? '‚úÖ Ready!' : 'üéÆ Ready Up';
                } else {
                    readyBtn.disabled = true;
                    readyBtn.className = 'btn btn-start btn-disabled';
                    readyBtn.innerHTML = '‚è≥ Waiting for players...';
                }
            }
        }
        
        const network = new GameNetwork();
        
        // ==================== GAME INITIALIZATION ====================
        function initGame() {
            // Hide loading screen
            document.getElementById('loading').classList.add('hidden');
            
            // Create Three.js scene
            canvas = document.getElementById('gameCanvas');
            
            // Check if Three.js is loaded
            if (typeof THREE === 'undefined') {
                showError('Three.js failed to load. Please refresh the page.');
                return;
            }
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f172a);
            scene.fog = new THREE.Fog(0x0f172a, 20, 100);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
            camera.position.set(0, 15, 25);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: true,
                alpha: true 
            });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Setup scene
            setupScene();
            
            // Start game loop
            gameLoop();
            
            // Setup event listeners
            setupEventListeners();
            
            showMessage('Welcome to Cube Defenders! Create or join a room to start playing.');
        }
        
        function setupScene() {
            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(20, 30, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Central cube (objective)
            const cubeGeometry = new THREE.BoxGeometry(5, 5, 5);
            const cubeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x10b981,
                emissive: 0x059669,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.9
            });
            centralCube = new THREE.Mesh(cubeGeometry, cubeMaterial);
            centralCube.position.set(0, 2.5, 0);
            centralCube.castShadow = true;
            centralCube.receiveShadow = true;
            scene.add(centralCube);
            
            // Player mesh
            const playerGeometry = new THREE.ConeGeometry(0.8, 2, 8);
            const playerMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x3b82f6,
                emissive: 0x3b82f6,
                emissiveIntensity: 0.2
            });
            playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
            playerMesh.castShadow = true;
            scene.add(playerMesh);
            
            // Arena floor
            const floorGeometry = new THREE.CircleGeometry(50, 64);
            const floorMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x1e293b,
                side: THREE.DoubleSide
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = Math.PI / 2;
            floor.position.y = -0.5;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Grid helper
            const gridHelper = new THREE.GridHelper(100, 50, 0x334155, 0x1e293b);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);
            
            // Decorative elements
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const radius = 15;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                const pillarGeometry = new THREE.CylinderGeometry(0.5, 0.5, 5, 8);
                const pillarMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x475569,
                    transparent: true,
                    opacity: 0.7
                });
                const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                pillar.position.set(x, 2.5, z);
                pillar.castShadow = true;
                scene.add(pillar);
            }
        }
        
        // ==================== GAME LOGIC ====================
        function spawnEnemies(count) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 25 + Math.random() * 15;
                const x = Math.cos(angle) * distance;
                const z = Math.sin(angle) * distance;
                
                const enemyGeometry = new THREE.SphereGeometry(0.8 + Math.random() * 0.5, 12, 12);
                const enemyMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xef4444,
                    emissive: 0xdc2626,
                    emissiveIntensity: 0.3
                });
                const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
                enemy.position.set(x, 1, z);
                enemy.castShadow = true;
                
                const enemyData = {
                    mesh: enemy,
                    speed: 0.03 + Math.random() * 0.04,
                    health: 1,
                    damage: 1,
                    target: { x: 0, y: 2.5, z: 0 }
                };
                
                scene.add(enemy);
                enemyMeshes.push(enemyData);
                gameState.enemies.push({
                    x: x,
                    y: 1,
                    z: z,
                    health: 1
                });
            }
        }
        
        function createBlock(position, color = 0x3b82f6) {
            if (!gameState.gameStarted) return;
            if (gameState.players[gameState.playerId]?.role !== 'builder') return;
            
            // Check block limit
            const playerBlocks = blockMeshes.filter(b => 
                Math.abs(b.mesh.position.x - position.x) < 0.1 && 
                Math.abs(b.mesh.position.z - position.z) < 0.1
            ).length;
            
            if (playerBlocks > 0) return;
            
            const blockGeometry = new THREE.BoxGeometry(2, 2, 2);
            const blockMaterial = new THREE.MeshPhongMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.8
            });
            const block = new THREE.Mesh(blockGeometry, blockMaterial);
            block.position.set(position.x, 1, position.z);
            block.castShadow = true;
            block.receiveShadow = true;
            
            const blockData = {
                mesh: block,
                health: 50 * gameState.upgrades.blockHealth,
                position: position
            };
            
            scene.add(block);
            blockMeshes.push(blockData);
            gameState.blocks.push({
                x: position.x,
                y: 1,
                z: position.z,
                health: blockData.health
            });
            
            // Update player stats
            if (gameState.players[gameState.playerId]) {
                gameState.players[gameState.playerId].stats.blocks++;
                network.updatePlayerList();
            }
            
            // Send to other players
            network.sendPlayerAction('placeBlock', {
                position: position,
                color: color
            });
        }
        
        function createProjectile(position, direction) {
            if (!gameState.gameStarted) return;
            if (gameState.players[gameState.playerId]?.role !== 'shooter') return;
            
            const projectileGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const projectileMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xf59e0b,
                emissive: 0xd97706,
                emissiveIntensity: 0.5
            });
            const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
            projectile.position.set(position.x, position.y, position.z);
            projectile.castShadow = true;
            
            const projectileData = {
                mesh: projectile,
                direction: direction,
                speed: 0.5,
                damage: 20 * gameState.upgrades.damage
            };
            
            scene.add(projectile);
            projectileMeshes.push(projectileData);
            gameState.projectiles.push({
                position: { x: position.x, y: position.y, z: position.z },
                direction: direction
            });
            
            // Send to other players
            network.sendPlayerAction('shoot', {
                position: position,
                direction: direction
            });
        }
        
        function updateGameObjects() {
            // Update player position
            const player = gameState.players[gameState.playerId];
            if (player) {
                playerMesh.position.set(player.position.x, player.position.y, player.position.z);
                playerMesh.material.color.setStyle(player.color);
                
                // Send position update
                network.sendPlayerAction('move', player.position);
            }
        }
        
        function gameLoop() {
            if (gameState.gameStarted) {
                // Update player movement
                updatePlayerMovement();
                
                // Update enemies
                updateEnemies();
                
                // Update projectiles
                updateProjectiles();
                
                // Update blocks
                updateBlocks();
                
                // Update time
                gameState.timeAlive += 1/60;
                
                // Check for new wave
                if (gameState.enemies.length === 0) {
                    gameState.wave++;
                    spawnEnemies(5 + gameState.wave * 2);
                    showUpgrades();
                }
                
                // Update UI
                updateGameUI();
                
                // Check game over
                if (gameState.cubeHealth <= 0) {
                    endGame();
                }
                
                // Sync game state periodically
                if (Math.floor(gameState.timeAlive * 60) % 30 === 0) {
                    network.syncGameState();
                }
            }
            
            // Camera follows player
            const player = gameState.players[gameState.playerId];
            if (player) {
                camera.position.x = player.position.x;
                camera.position.z = player.position.z + 20;
                camera.position.y = 15;
                camera.lookAt(player.position.x, player.position.y + 5, player.position.z);
            }
            
            // Animate central cube
            if (centralCube) {
                centralCube.rotation.x += 0.01;
                centralCube.rotation.y += 0.01;
            }
            
            // Render
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        function updatePlayerMovement() {
            if (!gameState.players[gameState.playerId]) return;
            
            const player = gameState.players[gameState.playerId];
            const speed = 0.15;
            
            // WASD Movement
            if (keys['w'] || keys['ArrowUp']) player.position.z -= speed;
            if (keys['s'] || keys['ArrowDown']) player.position.z += speed;
            if (keys['a'] || keys['ArrowLeft']) player.position.x -= speed;
            if (keys['d'] || keys['ArrowRight']) player.position.x += speed;
            
            // Keep within bounds
            const maxDistance = 40;
            const distance = Math.sqrt(player.position.x ** 2 + player.position.z ** 2);
            if (distance > maxDistance) {
                player.position.x = (player.position.x / distance) * maxDistance;
                player.position.z = (player.position.z / distance) * maxDistance;
            }
        }
        
        function updateEnemies() {
            for (let i = enemyMeshes.length - 1; i >= 0; i--) {
                const enemy = enemyMeshes[i];
                
                // Move towards cube
                const dx = enemy.target.x - enemy.mesh.position.x;
                const dz = enemy.target.z - enemy.mesh.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance > 3) {
                    enemy.mesh.position.x += (dx / distance) * enemy.speed;
                    enemy.mesh.position.z += (dz / distance) * enemy.speed;
                    
                    // Update game state
                    if (gameState.enemies[i]) {
                        gameState.enemies[i].x = enemy.mesh.position.x;
                        gameState.enemies[i].z = enemy.mesh.position.z;
                    }
                } else {
                    // Enemy reached cube
                    gameState.cubeHealth -= enemy.damage;
                    scene.remove(enemy.mesh);
                    enemyMeshes.splice(i, 1);
                    gameState.enemies.splice(i, 1);
                    
                    showMessage('Cube hit! Health: ' + Math.floor(gameState.cubeHealth));
                }
                
                // Bobbing animation
                enemy.mesh.position.y = 1 + Math.sin(Date.now() * 0.005 + i) * 0.2;
            }
        }
        
        function updateProjectiles() {
            for (let i = projectileMeshes.length - 1; i >= 0; i--) {
                const projectile = projectileMeshes[i];
                
                // Move projectile
                projectile.mesh.position.x += projectile.direction.x * projectile.speed;
                projectile.mesh.position.y += projectile.direction.y * projectile.speed;
                projectile.mesh.position.z += projectile.direction.z * projectile.speed;
                
                // Check collision with enemies
                for (let j = enemyMeshes.length - 1; j >= 0; j--) {
                    const enemy = enemyMeshes[j];
                    const dx = projectile.mesh.position.x - enemy.mesh.position.x;
                    const dy = projectile.mesh.position.y - enemy.mesh.position.y;
                    const dz = projectile.mesh.position.z - enemy.mesh.position.z;
                    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    
                    if (distance < 1.5) {
                        // Hit!
                        scene.remove(enemy.mesh);
                        enemyMeshes.splice(j, 1);
                        gameState.enemies.splice(j, 1);
                        
                        scene.remove(projectile.mesh);
                        projectileMeshes.splice(i, 1);
                        gameState.projectiles.splice(i, 1);
                        
                        // Update score and stats
                        gameState.score += 10;
                        if (gameState.players[gameState.playerId]) {
                            gameState.players[gameState.playerId].stats.kills++;
                            gameState.players[gameState.playerId].stats.damage += projectile.damage;
                            network.updatePlayerList();
                        }
                        
                        break;
                    }
                }
                
                // Remove if too far
                if (projectile.mesh.position.length() > 100) {
                    scene.remove(projectile.mesh);
                    projectileMeshes.splice(i, 1);
                    gameState.projectiles.splice(i, 1);
                }
            }
        }
        
        function updateBlocks() {
            for (let i = blockMeshes.length - 1; i >= 0; i--) {
                const block = blockMeshes[i];
                
                // Check collision with enemies
                for (let j = enemyMeshes.length - 1; j >= 0; j--) {
                    const enemy = enemyMeshes[j];
                    const dx = block.mesh.position.x - enemy.mesh.position.x;
                    const dz = block.mesh.position.z - enemy.mesh.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    if (distance < 2) {
                        block.health -= 1;
                        gameState.blocks[i].health = block.health;
                        
                        // Visual feedback
                        block.mesh.material.opacity = 0.5 + (block.health / (50 * gameState.upgrades.blockHealth)) * 0.3;
                        
                        if (block.health <= 0) {
                            scene.remove(block.mesh);
                            blockMeshes.splice(i, 1);
                            gameState.blocks.splice(i, 1);
                            break;
                        }
                    }
                }
            }
        }
        
        // ==================== UI FUNCTIONS ====================
        function updateGameUI() {
            document.getElementById('waveCount').textContent = gameState.wave;
            document.getElementById('enemiesLeft').textContent = enemyMeshes.length;
            document.getElementById('timeAlive').textContent = Math.floor(gameState.timeAlive);
            document.getElementById('cubeHealthText').textContent = Math.max(0, Math.floor(gameState.cubeHealth));
            
            const healthPercent = Math.max(0, gameState.cubeHealth);
            document.getElementById('cubeHealthBar').style.width = `${healthPercent}%`;
            
            // Update health bar color
            const healthBar = document.getElementById('cubeHealthBar');
            if (gameState.cubeHealth > 70) {
                healthBar.style.background = 'linear-gradient(90deg, #10b981, #059669)';
            } else if (gameState.cubeHealth > 30) {
                healthBar.style.background = 'linear-gradient(90deg, #f59e0b, #d97706)';
            } else {
                healthBar.style.background = 'linear-gradient(90deg, #ef4444, #dc2626)';
            }
        }
        
        function showUpgrades() {
            const container = document.getElementById('upgradesContainer');
            container.innerHTML = `
                <h3 style="color: #f59e0b; text-align: center;">Wave ${gameState.wave} Complete!</h3>
                <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 15px;">
                    <button class="btn" onclick="buyUpgrade('blockHealth')" ${gameState.score < Math.floor(gameState.upgrades.blockHealth * 100) ? 'disabled' : ''}>
                        üß± Stronger Blocks (+25% health) - $${Math.floor(gameState.upgrades.blockHealth * 100)}
                    </button>
                    <button class="btn" onclick="buyUpgrade('fireRate')" ${gameState.score < Math.floor(gameState.upgrades.fireRate * 100) ? 'disabled' : ''}>
                        ‚ö° Faster Shooting (+20% speed) - $${Math.floor(gameState.upgrades.fireRate * 100)}
                    </button>
                    <button class="btn" onclick="buyUpgrade('damage')" ${gameState.score < Math.floor(gameState.upgrades.damage * 100) ? 'disabled' : ''}>
                        üí• More Damage (+25% damage) - $${Math.floor(gameState.upgrades.damage * 100)}
                    </button>
                </div>
                <p style="text-align: center; margin-top: 10px; color: #94a3b8;">Score: $${gameState.score}</p>
            `;
            
            // Auto-hide after 15 seconds
            setTimeout(() => {
                if (gameState.gameStarted) {
                    container.innerHTML = '<p style="color: #94a3b8; text-align: center;">Upgrades unlock between waves</p>';
                }
            }, 15000);
        }
        
        function buyUpgrade(type) {
            const cost = Math.floor(gameState.upgrades[type] * 100);
            if (gameState.score >= cost) {
                gameState.score -= cost;
                gameState.upgrades[type] += type === 'blockHealth' || type === 'damage' ? 0.25 : 0.2;
                updateGameUI();
                showMessage(`‚úÖ ${type === 'blockHealth' ? 'Blocks' : type === 'fireRate' ? 'Fire rate' : 'Damage'} upgraded!`);
                showUpgrades(); // Refresh upgrade display
            } else {
                showError('Not enough score!');
            }
        }
        
        function startGame() {
            gameState.gameStarted = true;
            gameState.wave = 1;
            gameState.timeAlive = 0;
            gameState.cubeHealth = 100;
            gameState.score = 0;
            gameState.enemies = [];
            gameState.blocks = [];
            gameState.projectiles = [];
            
            // Clear existing meshes
            enemyMeshes.forEach(e => scene.remove(e.mesh));
            blockMeshes.forEach(b => scene.remove(b.mesh));
            projectileMeshes.forEach(p => scene.remove(p.mesh));
            
            enemyMeshes = [];
            blockMeshes = [];
            projectileMeshes = [];
            
            document.getElementById('waitingOverlay').classList.add('hidden');
            
            // Update status
            document.getElementById('statusMessage').className = 'status-message status-connected';
            document.getElementById('statusMessage').innerHTML = 'üéÆ Game Started! Defend the cube!';
            
            // Spawn initial enemies
            spawnEnemies(5);
            
            showMessage('Game started! Defend the central cube together!');
            
            // Sync final game state
            network.syncGameState();
        }
        
        function endGame() {
            gameState.gameStarted = false;
            
            const score = gameState.score + Math.floor(gameState.timeAlive * 10);
            const gameOverMsg = `Game Over! You survived ${Math.floor(gameState.timeAlive)} seconds on wave ${gameState.wave} with score: ${score}`;
            
            // Show game over overlay
            const overlay = document.getElementById('waitingOverlay');
            overlay.classList.remove('hidden');
            overlay.innerHTML = `
                <h2>üéÆ Game Over!</h2>
                <p>You survived ${Math.floor(gameState.timeAlive)} seconds</p>
                <p>Wave reached: ${gameState.wave}</p>
                <p>Final Score: ${score}</p>
                <button class="btn btn-start" onclick="resetToLobby()">üè† Back to Lobby</button>
            `;
            
            showMessage(gameOverMsg);
        }
        
        function resetToLobby() {
            gameState.gameStarted = false;
            gameState.wave = 1;
            gameState.timeAlive = 0;
            gameState.cubeHealth = 100;
            gameState.score = 0;
            gameState.enemies = [];
            gameState.blocks = [];
            gameState.projectiles = [];
            
            // Clear meshes
            enemyMeshes.forEach(e => scene.remove(e.mesh));
            blockMeshes.forEach(b => scene.remove(b.mesh));
            projectileMeshes.forEach(p => scene.remove(p.mesh));
            
            enemyMeshes = [];
            blockMeshes = [];
            projectileMeshes = [];
            
            // Reset player ready status
            if (gameState.players[gameState.playerId]) {
                gameState.players[gameState.playerId].ready = false;
            }
            
            // Show waiting overlay
            const overlay = document.getElementById('waitingOverlay');
            overlay.classList.remove('hidden');
            overlay.innerHTML = `
                <h2>üéÆ Cube Defenders</h2>
                <p>Create a room or join with a 4-digit code to start playing!</p>
                <p style="font-size: 1rem; color: #94a3b8;">Make sure all players are on the same WiFi network</p>
            `;
            
            // Show lobby UI
            document.getElementById('hostSection').classList.add('hidden');
            document.getElementById('joinSection').classList.remove('hidden');
            document.getElementById('readyBtn').classList.remove('hidden');
            
            updateGameUI();
            network.updatePlayerList();
            showMessage('Back to lobby. Create or join a new room!');
        }
        
        function showMessage(text) {
            const status = document.getElementById('statusMessage');
            status.textContent = text;
            status.className = 'status-message status-connected';
            setTimeout(() => {
                if (!gameState.gameStarted && gameState.roomCode) {
                    status.innerHTML = `üéÆ Room ${gameState.roomCode} - Waiting for players...`;
                } else if (!gameState.gameStarted) {
                    status.innerHTML = 'üîç Looking for rooms on your WiFi...';
                }
            }, 5000);
        }
        
        function showError(text) {
            const status = document.getElementById('statusMessage');
            status.textContent = text;
            status.className = 'status-message status-error';
            setTimeout(() => {
                status.className = 'status-message status-connecting';
                status.textContent = 'üîç Looking for rooms on your WiFi...';
            }, 3000);
        }
        
        // ==================== EVENT HANDLERS ====================
        function setupEventListeners() {
            // Keyboard events
            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                keys[key] = true;
                
                // Prevent space from scrolling
                if (key === ' ') {
                    e.preventDefault();
                    
                    // Place block (builder only)
                    if (gameState.gameStarted && gameState.players[gameState.playerId]?.role === 'builder') {
                        const player = gameState.players[gameState.playerId];
                        createBlock({ x: player.position.x, z: player.position.z - 3 });
                    }
                }
                
                // Shoot (shooter only)
                if (key === 'e' && gameState.gameStarted && gameState.players[gameState.playerId]?.role === 'shooter') {
                    const player = gameState.players[gameState.playerId];
                    const direction = {
                        x: -player.position.x * 0.1,
                        y: -0.2,
                        z: -player.position.z * 0.1
                    };
                    createProjectile({ x: player.position.x, y: player.position.y + 1, z: player.position.z }, direction);
                }
                
                // Special ability (R key)
                if (key === 'r' && gameState.gameStarted) {
                    // Special ability implementation
                    showMessage('Special ability activated!');
                }
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });
            
            // Mouse events
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / canvas.clientWidth) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / canvas.clientHeight) * 2 + 1;
                
                // Optional: Rotate player based on mouse
                if (playerMesh) {
                    playerMesh.rotation.y = mouse.x * Math.PI;
                }
            });
            
            // Button events
            document.getElementById('createBtn').addEventListener('click', () => {
                const roomCode = network.createRoom();
                document.getElementById('roomCode').textContent = roomCode;
                document.getElementById('hostSection').classList.remove('hidden');
                document.getElementById('joinSection').classList.add('hidden');
                document.getElementById('statusMessage').className = 'status-message status-connected';
                document.getElementById('statusMessage').innerHTML = `üéÆ Room created! Code: ${roomCode}`;
                document.getElementById('waitingOverlay').classList.add('hidden');
                showMessage(`Room ${roomCode} created! Share the code with your friend.`);
            });
            
            document.getElementById('joinBtn').addEventListener('click', () => {
                const roomCode = document.getElementById('roomInput').value.trim();
                if (network.joinRoom(roomCode)) {
                    document.getElementById('statusMessage').className = 'status-message status-connected';
                    document.getElementById('statusMessage').innerHTML = `üéÆ Joining room ${roomCode}...`;
                    document.getElementById('waitingOverlay').classList.add('hidden');
                    showMessage(`Joining room ${roomCode}...`);
                }
            });
            
            document.getElementById('copyBtn').addEventListener('click', () => {
                const roomCode = document.getElementById('roomCode').textContent;
                navigator.clipboard.writeText(roomCode).then(() => {
                    showMessage(`‚úÖ Room code ${roomCode} copied!`);
                }).catch(() => {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = roomCode;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    showMessage(`‚úÖ Room code ${roomCode} copied!`);
                });
            });
            
            document.getElementById('newCodeBtn').addEventListener('click', () => {
                const roomCode = network.generateRoomCode();
                gameState.roomCode = roomCode;
                network.currentRoom = roomCode;
                document.getElementById('roomCode').textContent = roomCode;
                showMessage(`üîÑ New room code: ${roomCode}`);
                network.syncGameState();
            });
            
            document.getElementById('readyBtn').addEventListener('click', () => {
                network.sendPlayerReady();
            });
            
            // Room input formatting
            document.getElementById('roomInput').addEventListener('input', (e) => {
                e.target.value = e.target.value.replace(/\D/g, '').slice(0, 4);
            });
            
            // Handle Enter key in room input
            document.getElementById('roomInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('joinBtn').click();
                }
            });
            
            // Window resize
            window.addEventListener('resize', () => {
                if (camera && canvas) {
                    camera.aspect = canvas.clientWidth / canvas.clientHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(canvas.clientWidth, canvas.clientHeight);
                }
            });
            
            // Handle page unload
            window.addEventListener('beforeunload', () => {
                if (network.isHost && gameState.roomCode) {
                    network.closeRoom();
                }
            });
        }
        
        // ==================== INITIALIZE ====================
        // Check if Three.js is loaded
        if (typeof THREE === 'undefined') {
            document.getElementById('loading').innerHTML = `
                <div style="text-align: center;">
                    <h2 style="color: #ef4444;">Error Loading Three.js</h2>
                    <p>Please check your internet connection and refresh the page.</p>
                    <button class="btn" onclick="location.reload()">üîÑ Refresh Page</button>
                </div>
            `;
        } else {
            // Initialize when page loads
            window.addEventListener('load', initGame);
        }
    </script>
</body>
</html>
